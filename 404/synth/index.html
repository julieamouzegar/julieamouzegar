<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
  <meta charset="utf-8">
  <title></title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <style>
    :root {
  --depth: 0;
}

html {
  box-sizing: border-box;
  background: black;
  font-size: calc(12px + .2vw);
  font-family: sans-serif;
  font-weight: 300;
  scroll-behavior: smooth;
  line-height: 2em;
  text-shadow: 0 0 .1rem black, 0 0 .1rem black;
  font-weight: 100;
}

*, *:before, *:after {
  box-sizing: inherit;
}

* {
  margin: 0;
  padding: 0;
}

body {
  color: white;
}

h2 {
  font-size: 1.618em;
  padding-top: 1em;
  padding-bottom: 1em;
}

p {
  padding-bottom: 1em;
}

details {
  margin-left: .5em;
}

#controls {
  /*background: rgba(0, 0, 0, .5);*/
  padding-right: .5em;
  width: 100%;
}

#controls h1 {
  font-size: 1.6em;
  text-align: center;
  margin-top: 2em;
  margin-bottom: 1em;
}

#controls #mode-selectors, #descriptions {
  text-align: center;
}

#controls .child-controls {
  margin-left: .3em;
  border-left: .1em solid hsl(calc(0 + var(--depth, 0) * 100 ), 100%, 50%);
}

summary::marker {
  color: hsl(calc(0 + var(--depth, 0) * 100 ), 100%, 50%);
}

#controls .child-controls .property {
  margin-left: 1.55em;
  display: flex;
  align-items: center;
}

#controls .child-controls .property .label {
  margin-right: .5em;
}

#controls .child-controls .property .value {
  min-width: 4.5em;
}

#controls input[type="color"] {
  width: 100%;
  height: 1.6em;
}

#controls .color-box {
  width: 5em;
  height: 1em;
  display: inline-block;
  margin-left: .4em;
}

.controls-grid {
  display: grid;
  grid-template-columns: 8em auto;
  margin-top: 1em;
}

.controls-grid > label {
  text-align: right;
  padding-right: .5em;
}

.state-properties {
  display: grid;
  grid-template-columns: 12em 8em auto;
  grid-auto-columns: min-content;
}

#mode-selectors {
  margin-top: 1em;
}

.property-label {
  text-align: right;
}

#controls > div {
  margin-top: .5em;
  margin-bottom: .5em;
}

#controls-action {
  width: 100%;
  height: 2rem;
}

#default-mapping-reference {
  font-family: monospace;
  white-space: pre;
  overflow-x: auto;
}

#experience-title {
  font-family: sans-serif;
  background: transparent;
  width: 100%;
  height: auto;
  color: white;
  border-top: .3em;
  border-bottom: 3em;
  font-size: 1.3em;
  text-align: center;
}

#experience-description {
  font-family: sans-serif;
  background: transparent;
  width: 100%;
  color: white;
  border-top: .3em;
  border-bottom: 3em;
  font-size: 1em;
  line-height: 2em;
}

#mapping-editor {
  background: transparent;
  width: 100%;
  height: 30vh;
  color: white;
  border-top: .3em;
  border-bottom: 3em;
  font-size: 1em;
}

#mapping-errors {
  color: red;
}

audio {
  width: 100%;
}

.state-properties {
  margin-top: 1em;
  margin-bottom: 1em;
}

input {
  font-size: 1em;
  border: 0;
  line-height: 2em;
}

button, input, select, option, label {
  font-size: 1em;
  font-weight: 300 !important;
  border: 0;
  background: transparent;
  color: white;
  text-decoration: underline;
  transition: background 1s, color 1s, text-shadow 1s;
}

button:hover, input:hover, select:hover, option:hover, label:hover {
  background: white;
  color: black;
  text-shadow: none;
}

.visualizer-action-button {
  background-color: rgba(80,60,40,0.75);
  margin: 10px;
  padding: 10px;
}

label {
  margin-right: 1em;
}

option {
  font-size: 1em;
  border: 0;
  color: black;
}

.slider {
  width: 100%;
}

.iphone-proportions {
  width: 56vh;
  height: 100vh;
}

.ipad-proportions {
  width: 30vh;
  height: 100vh;
}

.hidden {
  opacity: 0;
  max-height: 0;
  height: 0;
  visibility: hidden;
}

.actions {
  text-align: center;
}

#descriptions > div:not(.hidden) {
  opacity: 1;
  max-height: auto;
  transition: opacity 4s;
}

.frequencies-preview {
  display: flex;
}

.analyser-preview {
  width: 100%;
  height: 8em;
}

.frequencies-preview > .analyser-preview {
  width: 50%;
  flex-grow: 1;
}

/* preview: start */

body.preview-fullscreen {
  margin-top: 100vh;
}

body:not(.preview-fullscreen) {
  display: flex;
}

body.preview-iphone-landscape {
  flex-direction: column;
  overflow: hidden;
}

body:not(.preview-fullscreen) #controls {
  overflow-y: scroll;
  max-height: 100vh;
}

body.preview-fullscreen #preview {
  width: 100vw;
  height: 100vh;
  position: fixed;
  top: 0px;
  left: 0px;
  z-index: -9999;
}

body.preview-iphone #preview {
  min-width: 46.15vh;
  width: 46.15vh;
  height: 100vh;
}

body.preview-ipad #preview {
  min-width: 75vh;
  width: 75vh;
  height: 100vh;
}

body.preview-iphone-landscape #preview {
  min-width: 100vw;
  width: 100vw;
  height: 46.15vw;
}

body.preview-ipad-landscape #preview {
  min-width: 133.3vh;
  width: 133.3vh;
  height: 100vh;
}

body.preview-square #preview {
  min-width: 100vh;
  width: 100vh;
  height: 100vh;
}

body.preview-4x5 #preview {
  min-width: 80vh;
  width: 80vh;
  height: 100vh;
}

/* preview: end */
  </style>
  <script>
    // -- https://xemantic.github.io/shader-web-background/
const shaderWebBackground={};(()=>{'use strict';const r=(a,b)=>{b.initHalfFloatRGBATexture(b.width,b.height);a.texParameteri(a.TEXTURE_2D,
a.TEXTURE_MIN_FILTER,a.LINEAR);a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MAG_FILTER,
a.LINEAR);a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE);a.texParameteri(a.TEXTURE_2D,
a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE);return{width:b.width,height:b.height}},y=(a,b)=>
{console.warn("shader-web-background cannot shade, adding fallback CSS classes");
document.documentElement.classList.add("shader-web-background-fallback");b.classList.add("shader-web-background-fallback");
if(a instanceof shaderWebBackground.GlError)console.warn("Not sufficient WebGL support:",
a);else throw a;};
function z(a,b){if(!a)throw new shaderWebBackground.ConfigError(b);}
function A(a){z(a instanceof HTMLCanvasElement,"config.canvas must be instance of canvas");
return a}
function B(){const a=document.createElement("canvas"),b=a.style;a.id="shader-web-background";b.width=
"100vw";b.height="100vh";b.position="fixed";b.top="0";b.left="0";b.zIndex=-9999;return a}
function C(a,b,d){z(a instanceof HTMLScriptElement&&a.type===b,'Shader source element of id "'+
d+'" should be of type: <script type="'+(b+'" id="'+d+'">'))}
function E(a){const b=document.getElementById(a);z(b,'Missing shader source: <script type="x-shader/x-fragment" id="'+
(a+'">'));C(b,"x-shader/x-fragment",a);return b.text}
function F(a){a+="Vertex";const b=document.getElementById(a);return b?(C(b,"x-shader/x-vertex",
a),b.text):"attribute vec2 V;void main(){gl_Position=vec4(V,0,1);}"}
function G(a,b){"loading"!==document.readyState?b():window.addEventListener(a,b)}
class H{constructor(a,b,d){this.g=b;this.h=()=>{for(const c of d)c()};this.i=()=>
{var c=b.u,e=a.gl;e.bindBuffer(e.ARRAY_BUFFER,a.j);e.enableVertexAttribArray(c);e.vertexAttribPointer(c,
2,e.FLOAT,!1,0,0);e.drawArrays(e.TRIANGLE_STRIP,0,4);e.disableVertexAttribArray(c);
e.bindBuffer(e.ARRAY_BUFFER,null);c=a.gl;for(e=0;e<a.g;e++)c.activeTexture(c.TEXTURE0+
e),c.bindTexture(c.TEXTURE_2D,null);a.g=0}}}
function I(a){var b={antialias:!1,depth:!1,alpha:!1};try{return new J(a,b)}catch(d){throw new shaderWebBackground.GlError(d.message);
}}
function K(a,b,d,c,e,n,u){function w(f,k,m){try{{var h=g;const p=h.gl,R=L(h,f,p.VERTEX_SHADER,k),
S=L(h,f,p.FRAGMENT_SHADER,m),x=p.createProgram();p.attachShader(x,R);p.attachShader(x,
S);p.linkProgram(x);var q=x}return q}catch(p){throw new shaderWebBackground.ConfigError(p.message);
}}const g=I(b),l=[];a.gl=g.gl;a.canvas=b;a.width=0;a.height=0;a.cssPixelRatio=0;a.cssWidth=
0;a.cssHeight=0;a.isOverShader=(f,k)=>{const m=b.getBoundingClientRect();return f>=
m.left&&f<=m.right&&k>=m.top&&k<=m.bottom};a.toShaderX=f=>(f-b.getBoundingClientRect().left)*
a.cssPixelRatio+.5;a.toShaderY=f=>b.height-(f-b.getBoundingClientRect().top)*a.cssPixelRatio-
.5;const v=()=>{const f=window.devicePixelRatio||1,k=b.clientWidth,m=b.clientHeight,
h=Math.floor(k*f),q=Math.floor(m*f);b.width=h;b.height=q;a.width=h;a.height=q;a.cssPixelRatio=
f;a.cssWidth=k;a.cssHeight=m;a.resolution=[h,q];for(const p of l)p.g.l(h,q)};a.buffers=
{};a.initHalfFloatRGBATexture=(f,k)=>{g.h.g(f,k)};const T=Object.keys(d).length-1;
let U=0;for(const f in d){if(U++<T){const h=d[f].texture||r;a.buffers[f]=M(g,()=>
h(g.gl,a))}const k=N(g,w(f,F(f),E(f)),a.buffers[f]),m=d[f].uniforms||{};var t=Object.keys(m);
for(const h of k.o)z(m[h.name],'No configuration for uniform "'+h.name+'" defined in shader "'+
f+'"'),t=t.filter(q=>q!==h.name);0!==t.length&&console.warn('Extra uniforms configured for shader "'+
f+'", which are not present in the shader code - might have been removed by GLSL compiler if not used: '+
t.join(", "));t=k.o.map(h=>{const q=m[h.name];return"function"===typeof q?()=>{const p=
q(h.location);h.m(p)}:()=>{h.m(q)}});l.push(new H(g,k,t))}const D=()=>{requestAnimationFrame(D);
if(0<b.getBoundingClientRect().top+b.height&&b.getBoundingClientRect().top<(window.innerHeight||
document.documentElement.clientHeight)){if(a.cssWidth!==b.clientWidth||a.cssHeight!==
b.clientHeight){v();var f=!0}else f=!1;f&&e&&e(a.width,a.height);n&&n();for(const k of l)k.g.i(k.h,
k.i);u&&u()}};G("load",()=>{v();c&&c();e&&e(a.width,a.height);requestAnimationFrame(D)})}
shaderWebBackground.Error=class extends Error{constructor(a){super(a);this.name="shaderWebBackground.Error"}};
shaderWebBackground.ConfigError=class extends shaderWebBackground.Error{constructor(a){super(a);
this.name="shaderWebBackground.ConfigError"}};
shaderWebBackground.GlError=class extends shaderWebBackground.Error{constructor(a){super(a);this.name=
"shaderWebBackground.GlError"}};
shaderWebBackground.shade=function(a){z(a,"Missing configurer argument");const b=
{};a=a(b);const d=a.canvas?A(a.canvas):B();z(a.shaders,"No shaders specified in config");
try{return K(b,d,a.shaders,a.onInit,a.onResize,a.onBeforeFrame,a.onAfterFrame),a.canvas||
G("DOMContentLoaded",()=>{document.body.appendChild(d)}),b}catch(c){(a.onError||y)(c,
d)}};const O=[-1,1,1,1,-1,-1,1,-1];
function P(a,b){return a.j(a.gl.getExtension(b),b+" extension is not supported")}
class Q{constructor(a,b){this.gl=a;this.j=b}g(){}}
class V extends Q{constructor(a,b){super(a,b);this.h=P(this,"OES_texture_half_float");
P(this,"OES_texture_half_float_linear")}g(a,b){const d=this.gl;d.texImage2D(d.TEXTURE_2D,
0,d.RGBA,a,b,0,d.RGBA,this.h.HALF_FLOAT_OES,null)}}
class W extends Q{constructor(a,b){super(a,b);P(this,"EXT_color_buffer_float");this.gl.getExtension("OES_texture_float_linear")}g(a,
b){const d=this.gl;d.texImage2D(d.TEXTURE_2D,0,d.RGBA16F,a,b,0,d.RGBA,d.HALF_FLOAT,
null)}}
function aa(a){a=a.split(/\r?\n/);const b=a.length.toString().length;var d=[];a.forEach((c,
e)=>{e=(e+1).toString();e=e.length>=b?e:" ".repeat(b-e.length)+e;d.push(e+": "+c+
"\n")});return d.join("")}const X=a=>a.map(b=>b?1:0);
function M(a,b){return new Y(a.gl,()=>b(a.gl))}
function N(a,b,d){const c=a.gl,e=[],n=c.getProgramParameter(b,c.ACTIVE_UNIFORMS);
for(let g=0;g<n;g++){const l=c.getActiveUniform(b,g),v=c.getUniformLocation(b,l.name);
e.push({name:l.name,info:l,location:v,m:ba(a,v,l.type)})}let u=0,w=0;return{u:c.getAttribLocation(b,
"V"),o:e,l:d?(g,l)=>d.l(g,l):(g,l)=>{u=g;w=l},i:(g,l)=>{c.useProgram(b);g();d?(c.viewport(0,
0,d.width,d.height),g=d.g,d.g=d.h,d.h=g,d.i(l)):(c.viewport(0,0,u,w),l())}}}
function L(a,b,d,c){a=a.gl;d=a.createShader(d);a.shaderSource(d,c);a.compileShader(d);
if(!a.getShaderParameter(d,a.COMPILE_STATUS)){const e=String(a.getShaderInfoLog(d));
a.deleteShader(d);b="Cannot compile shader - "+b+": "+e;console.log(b);console.log(aa(c));
throw Error(b);}return d}
function ba(a,b,d){const c=a.gl;switch(d){case c.FLOAT:d=e=>c.uniform1f(b,e);break;
case c.FLOAT_VEC2:d=e=>c.uniform2fv(b,e);break;case c.FLOAT_VEC3:d=e=>c.uniform3fv(b,
e);break;case c.FLOAT_VEC4:d=e=>c.uniform4fv(b,e);break;case c.INT:d=e=>c.uniform1i(b,
e);break;case c.INT_VEC2:d=e=>c.uniform2iv(b,e);break;case c.INT_VEC3:d=e=>c.uniform3iv(b,
e);break;case c.INT_VEC4:d=e=>c.uniform4iv(b,e);break;case c.BOOL:d=e=>c.uniform1i(b,
e?1:0);break;case c.BOOL_VEC2:d=e=>c.uniform2iv(b,X(e));break;case c.BOOL_VEC3:d=
e=>c.uniform3iv(b,X(e));break;case c.BOOL_VEC4:d=e=>c.uniform4iv(b,X(e));break;case c.FLOAT_MAT2:d=
e=>c.uniformMatrix2fv(b,!1,e);break;case c.FLOAT_MAT3:d=e=>c.uniformMatrix3fv(b,!1,
e);break;case c.FLOAT_MAT4:d=e=>c.uniformMatrix4fv(b,!1,e);break;case c.SAMPLER_2D:d=
e=>{{const n=a.gl;e=e instanceof Y?e.g:e;n.activeTexture(n.TEXTURE0+a.g);n.bindTexture(n.TEXTURE_2D,
e);n.uniform1i(b,a.g++)}};break;default:throw Error("unknown type");}return d}
class J{constructor(a,b){this.canvas=a;const d=(e,n)=>{if(!e)throw Error(n);return e};
let c=a.getContext("webgl2",b);if(c)this.h=new W(c,d);else if(c=a.getContext("webgl",
b))this.h=new V(c,d);d(c,"webgl context not supported on supplied canvas element: "+
a);this.gl=c;a=c.createBuffer();c.bindBuffer(c.ARRAY_BUFFER,a);c.bufferData(c.ARRAY_BUFFER,
new Float32Array(O),c.STATIC_DRAW);c.bindBuffer(c.ARRAY_BUFFER,null);this.j=a;this.buffers=
{};this.g=0}}
function Z(a){const b=a.gl,d=b.createTexture();b.bindTexture(b.TEXTURE_2D,d);const c=
a.s(b);a.width=c.width;a.height=c.height;b.bindTexture(b.TEXTURE_2D,null);return d}
class Y{constructor(a,b){this.j=a.createFramebuffer();this.gl=a;this.s=b;this.g=this.h=
null;this.height=this.width=0}l(){this.h&&this.gl.deleteTexture(this.h);this.g&&this.gl.deleteTexture(this.g);
this.h=Z(this);this.g=Z(this)}i(a){const b=this.gl;b.bindFramebuffer(b.FRAMEBUFFER,
this.j);b.framebufferTexture2D(b.FRAMEBUFFER,b.COLOR_ATTACHMENT0,b.TEXTURE_2D,this.g,
0);a();b.framebufferTexture2D(b.FRAMEBUFFER,b.COLOR_ATTACHMENT0,b.TEXTURE_2D,null,
0);b.bindFramebuffer(b.FRAMEBUFFER,null)}};})()
  </script>
  <script type="x-shader/x-fragment" id="audio">
    precision highp float;
// no version here - we need to adhere to WebGL 1 for Apple devices, therefore only GLSL 1 syntax
// Note: Phase uniforms might either represent angle or shift
// Note: this shader is rendering a texture of limited size, so the "if" sequence is not degrading performace much

uniform vec2      iResolution;
uniform sampler2D iTextureLeftFrequencies;
uniform sampler2D iTextureRightFrequencies;
uniform sampler2D iTextureWaveform;

uniform float     iFeedbackZoomFrequencyImpact;
uniform float     iFeedbackZoomFrequencyRangeMin;
uniform float     iFeedbackZoomFrequencyRangeMax;
uniform bool      iFeedbackZoomFrequencyRangeLogScale;
uniform float     iFeedbackZoomFrequencyLoudnessMin;
uniform float     iFeedbackZoomFrequencyLoudnessMax;
uniform float     iFeedbackZoomFrequencyLoudnessCurve;
uniform float     iFeedbackZoomFrequencyPhase;

uniform float     iFeedbackZoomWaveformImpact;
uniform bool      iFeedbackZoomWaveformMirror;
uniform float     iFeedbackZoomWaveformPhase;

uniform float     iFeedbackShiftFrequencyHorizontalImpact;
uniform float     iFeedbackShiftFrequencyHorizontalRangeMin;
uniform float     iFeedbackShiftFrequencyHorizontalRangeMax;
uniform bool      iFeedbackShiftFrequencyHorizontalRangeLogScale;
uniform float     iFeedbackShiftFrequencyHorizontalLoudnessMin;
uniform float     iFeedbackShiftFrequencyHorizontalLoudnessMax;
uniform float     iFeedbackShiftFrequencyHorizontalLoudnessCurve;
uniform bool      iFeedbackShiftFrequencyLogScale;
uniform float     iFeedbackShiftFrequencyVerticalImpact;
uniform float     iFeedbackShiftFrequencyVerticalRangeMin;
uniform float     iFeedbackShiftFrequencyVerticalRangeMax;
uniform bool      iFeedbackShiftFrequencyVerticalRangeLogScale;
uniform float     iFeedbackShiftFrequencyVerticalLoudnessMin;
uniform float     iFeedbackShiftFrequencyVerticalLoudnessMax;
uniform float     iFeedbackShiftFrequencyVerticalLoudnessCurve;

uniform float     iFeedbackShiftWaveformHorizontalImpact;
uniform float     iFeedbackShiftWaveformVerticalImpact;

uniform float     iDrawShapeFrequencyImpact;
uniform float     iDrawShapeFrequencyRangeMin;
uniform float     iDrawShapeFrequencyRangeMax;
uniform bool      iDrawShapeFrequencyRangeLogScale;
uniform float     iDrawShapeFrequencyLoudnessMin;
uniform float     iDrawShapeFrequencyLoudnessMax;
uniform float     iDrawShapeFrequencyLoudnessCurve;
uniform float     iDrawShapeFrequencyPhase;

uniform float     iDrawShapeSliceFrequencyRangeMin;
uniform float     iDrawShapeSliceFrequencyRangeMax;
uniform bool      iDrawShapeSliceFrequencyRangeLogScale;
uniform float     iDrawShapeSliceFrequencyLoudnessMin;
uniform float     iDrawShapeSliceFrequencyLoudnessMax;
uniform float     iDrawShapeSliceFrequencyLoudnessCurve;
uniform float     iDrawShapeSliceFrequencyPhase;

uniform float     iDrawNoiseSliceFrequencyRangeMin;
uniform float     iDrawNoiseSliceFrequencyRangeMax;
uniform bool      iDrawNoiseSliceFrequencyRangeLogScale;
uniform float     iDrawNoiseSliceFrequencyLoudnessMin;
uniform float     iDrawNoiseSliceFrequencyLoudnessMax;
uniform float     iDrawNoiseSliceFrequencyLoudnessCurve;
uniform float     iDrawNoiseSliceFrequencyPhase;

float mapFrom01(in float value, in float min, in float max) {
  return min + value * (max - min);
}

float mapTo01(in float value, in float min, in float max) {
  return (value - min) / (max - min);
}

float getFrequency(
  in float x,
  in float impact,
  in float minFreq,
  in float maxFreq,
  in bool  logScale,
  in float minDb,
  in float maxDb,
  in float dbCurve,
  in float phase,
  in bool  stereo
) {
  float repeatedX = mod(x + phase, 1.);
  float stX = stereo ? ((.5 - repeatedX) * 2.) : x;
  float freq = mapFrom01(abs(stX), minFreq, maxFreq);
  if (logScale) {
    freq = pow(freq, 2.);
  }
  float signal = (stX > 0.)
    ? texture2D(iTextureLeftFrequencies, vec2(freq, .5)).r
    : texture2D(iTextureRightFrequencies, vec2(freq, .5)).r;
  signal = mapTo01(signal, minDb, maxDb);
  signal = pow(signal, dbCurve);
  return clamp(signal, 0., 1.) * impact;
}

float getWaveform(in float x, in float impact, in bool mirror, in float phase) {
  float repeatedX = mod(x + phase, 1.);
  return texture2D(
    iTextureWaveform,
    vec2(mirror ? abs((.5 - repeatedX) * 2.) : repeatedX, .5)
  ).r * impact;
}

// TODO if statemetns should be solved with gl.viewport / gl.scissors and multiple shaders rendering to the same texture
void main() {
  vec2 uv = gl_FragCoord.xy / iResolution;
  int row = int(gl_FragCoord.y);
  float signal;
  if (row == 0) {        // visualizer.feedback.zoom.frequency
    signal = getFrequency(
      uv.x,
      iFeedbackZoomFrequencyImpact,
      iFeedbackZoomFrequencyRangeMin,
      iFeedbackZoomFrequencyRangeMax,
      iFeedbackZoomFrequencyRangeLogScale,
      iFeedbackZoomFrequencyLoudnessMin,
      iFeedbackZoomFrequencyLoudnessMax,
      iFeedbackZoomFrequencyLoudnessCurve,
      iFeedbackZoomFrequencyPhase,
      true
    );
  } else if (row == 1) { // visualizer.feedback.zoom.waveform
    signal = getWaveform(
      uv.x,
      iFeedbackZoomWaveformImpact,
      iFeedbackZoomWaveformMirror,
      iFeedbackZoomWaveformPhase
    );
  } else if (row == 2) { // visualizer.feedback.shift.frequency.horizontal
    signal = getFrequency(
      uv.x,
      iFeedbackShiftFrequencyHorizontalImpact,
      iFeedbackShiftFrequencyHorizontalRangeMin,
      iFeedbackShiftFrequencyHorizontalRangeMax,
      iFeedbackShiftFrequencyHorizontalRangeLogScale,
      iFeedbackShiftFrequencyHorizontalLoudnessMin,
      iFeedbackShiftFrequencyHorizontalLoudnessMax,
      iFeedbackShiftFrequencyHorizontalLoudnessCurve,
      0.,
      true
    );
  } else if (row == 3) { // visualizer.feedback.shift.frequency.vertical
    signal = getFrequency(
      uv.x,
      iFeedbackShiftFrequencyVerticalImpact,
      iFeedbackShiftFrequencyVerticalRangeMin,
      iFeedbackShiftFrequencyVerticalRangeMax,
      iFeedbackShiftFrequencyVerticalRangeLogScale,
      iFeedbackShiftFrequencyVerticalLoudnessMin,
      iFeedbackShiftFrequencyVerticalLoudnessMax,
      iFeedbackShiftFrequencyVerticalLoudnessCurve,
      0.,
      true
    );
  } else if (row == 4) { // visualizer.feedback.shift.waveform.horizontal
    signal = getWaveform(
      uv.x,
      iFeedbackShiftWaveformHorizontalImpact,
      false,
      0.
    );
  } else if (row == 5) { // visualizer.feedback.shift.waveform.vertical
    signal = getWaveform(
      uv.x,
      iFeedbackShiftWaveformVerticalImpact,
      false,
      0.
    );
  } else if (row == 6) {
    signal = getFrequency(
      uv.x,
      iDrawShapeFrequencyImpact,
      iDrawShapeFrequencyRangeMin,
      iDrawShapeFrequencyRangeMax,
      iDrawShapeFrequencyRangeLogScale,
      iDrawShapeFrequencyLoudnessMin,
      iDrawShapeFrequencyLoudnessMax,
      iDrawShapeFrequencyLoudnessCurve,
      iDrawShapeFrequencyPhase,
      true
    );
  } else if (row == 7) {
    signal = getFrequency(
      uv.x,
      1., // comes with apply parameter instead of impact
      iDrawShapeSliceFrequencyRangeMin,
      iDrawShapeSliceFrequencyRangeMax,
      iDrawShapeSliceFrequencyRangeLogScale,
      iDrawShapeSliceFrequencyLoudnessMin,
      iDrawShapeSliceFrequencyLoudnessMax,
      iDrawShapeSliceFrequencyLoudnessCurve,
      iDrawShapeSliceFrequencyPhase,
      false // it takes only right channel by default
    );
  } else {
    signal = getFrequency(
      uv.x,
      1., // comes with apply parameter instead of impact
      iDrawNoiseSliceFrequencyRangeMin,
      iDrawNoiseSliceFrequencyRangeMax,
      iDrawNoiseSliceFrequencyRangeLogScale,
      iDrawNoiseSliceFrequencyLoudnessMin,
      iDrawNoiseSliceFrequencyLoudnessMax,
      iDrawNoiseSliceFrequencyLoudnessCurve,
      iDrawNoiseSliceFrequencyPhase,
      false // it takes only right channel by default
    );
  }
  gl_FragColor = vec4(vec3(signal), 1.);
}
  </script>
  <script type="x-shader/x-fragment" id="analyserFrequency">
    precision highp float;
// no version here - we need to adhere to WebGL 1 for Apple devices, therefore only GLSL 1 syntax

uniform vec2      iResolution;
uniform sampler2D iAnalyserFrequencyTexture;
uniform bool      iAnalyserFrequencyLogScale;

// -- Libs: start

float saturate(in float x) {
  return min(1.0, max(0.0, x));
}

// Copyright 2019 Google LLC.
// SPDX-License-Identifier: Apache-2.0

// Polynomial approximation in GLSL for the Turbo colormap
// Original LUT: https://gist.github.com/mikhailov-work/ee72ba4191942acecc03fe6da94fc73f

// Authors:
//   Colormap Design: Anton Mikhailov (mikhailov@google.com)
//   GLSL Approximation: Ruofei Du (ruofei@google.com)

vec3 TurboColormap(in float x) {
  const vec4 kRedVec4 = vec4(0.13572138, 4.61539260, -42.66032258, 132.13108234);
  const vec4 kGreenVec4 = vec4(0.09140261, 2.19418839, 4.84296658, -14.18503333);
  const vec4 kBlueVec4 = vec4(0.10667330, 12.64194608, -60.58204836, 110.36276771);
  const vec2 kRedVec2 = vec2(-152.94239396, 59.28637943);
  const vec2 kGreenVec2 = vec2(4.27729857, 2.82956604);
  const vec2 kBlueVec2 = vec2(-89.90310912, 27.34824973);

  x = saturate(x);
  vec4 v4 = vec4( 1.0, x, x * x, x * x * x);
  vec2 v2 = v4.zw * v4.z;
  return vec3(
    dot(v4, kRedVec4)   + dot(v2, kRedVec2),
    dot(v4, kGreenVec4) + dot(v2, kGreenVec2),
    dot(v4, kBlueVec4)  + dot(v2, kBlueVec2)
  );
}

// -- Libs: end

float mapFrom01(in float value, in float min, in float max) {
  return min + value * (max - min);
}

void main() {
  vec2 uv = gl_FragCoord.xy / iResolution;
  vec2 texUv = vec2(
    iAnalyserFrequencyLogScale ? pow(uv.x, 2.) : uv.x,
    .5
  );
  // convert from negative decibel scale - no signal=-Infinity, lowest=-100, highest=0
  float signal = texture2D(iAnalyserFrequencyTexture, texUv).r / 100. + 1.;
  vec3 color = TurboColormap(signal) * step(uv.y, signal);
  gl_FragColor = vec4(color, 1.);
}
  </script>
  <script type="x-shader/x-fragment" id="analyserWaveform">
    precision highp float;
// no version here - we need to adhere to WebGL 1 for Apple devices, therefore only GLSL 1 syntax

uniform vec2      iResolution;
uniform sampler2D iAnalyserWaveformTexture;

// -- Libs: start

float saturate(in float x) {
  return min(1.0, max(0.0, x));
}

// Copyright 2019 Google LLC.
// SPDX-License-Identifier: Apache-2.0

// Polynomial approximation in GLSL for the Turbo colormap
// Original LUT: https://gist.github.com/mikhailov-work/ee72ba4191942acecc03fe6da94fc73f

// Authors:
//   Colormap Design: Anton Mikhailov (mikhailov@google.com)
//   GLSL Approximation: Ruofei Du (ruofei@google.com)

vec3 TurboColormap(in float x) {
  const vec4 kRedVec4 = vec4(0.13572138, 4.61539260, -42.66032258, 132.13108234);
  const vec4 kGreenVec4 = vec4(0.09140261, 2.19418839, 4.84296658, -14.18503333);
  const vec4 kBlueVec4 = vec4(0.10667330, 12.64194608, -60.58204836, 110.36276771);
  const vec2 kRedVec2 = vec2(-152.94239396, 59.28637943);
  const vec2 kGreenVec2 = vec2(4.27729857, 2.82956604);
  const vec2 kBlueVec2 = vec2(-89.90310912, 27.34824973);

  x = saturate(x);
  vec4 v4 = vec4( 1.0, x, x * x, x * x * x);
  vec2 v2 = v4.zw * v4.z;
  return vec3(
    dot(v4, kRedVec4)   + dot(v2, kRedVec2),
    dot(v4, kGreenVec4) + dot(v2, kGreenVec2),
    dot(v4, kBlueVec4)  + dot(v2, kBlueVec2)
  );
}

// -- Libs: end

float mapFrom01(in float value, in float min, in float max) {
  return min + value * (max - min);
}

void main() {
  vec2 uv = gl_FragCoord.xy / iResolution;
  float signal = (texture2D(iAnalyserWaveformTexture, uv).r + 1.) * .5;
  vec3 color = TurboColormap(signal) * step(uv.y, signal);
  gl_FragColor = vec4(color, 1.);
}
  </script>
  <script type="x-shader/x-fragment" id="noise">
    precision highp float;
// no version here - we need to adhere to WebGL 1 for Apple devices, therefore only GLSL 1 syntax

uniform vec2      iResolution;
uniform float     iMinDimension;

uniform bool      iDrawNoiseApply;
uniform float     iDrawNoiseScale;
uniform vec2      iDrawNoiseShift;
uniform float     iDrawNoisePhase;

uniform float     iFeedbackNoiseImpact;
uniform float     iFeedbackNoiseScale;
uniform vec2      iFeedbackNoiseShift;
uniform float     iFeedbackNoisePhase;


//
//  Wombat
//  An efficient texture-free GLSL procedural noise library
//  Source: https://github.com/BrianSharpe/Wombat
//  Derived from: https://github.com/BrianSharpe/GPU-Noise-Lib
//
//  I'm not one for copyrights.  Use the code however you wish.
//  All I ask is that credit be given back to the blog or myself when appropriate.
//  And also to let me know if you come up with any changes, improvements, thoughts or interesting uses for this stuff. :)
//  Thanks!
//
//  Brian Sharpe
//  brisharpe CIRCLE_A yahoo DOT com
//  http://briansharpe.wordpress.com
//  https://github.com/BrianSharpe
//

//
//  Perlin Noise 3D
//  Return value range of -1.0->1.0
//
float Perlin3D(vec3 P)
{
  //  https://github.com/BrianSharpe/Wombat/blob/master/Perlin3D.glsl

  // establish our grid cell and unit position
  vec3 Pi = floor(P);
  vec3 Pf = P - Pi;
  vec3 Pf_min1 = Pf - 1.0;

  // clamp the domain
  Pi.xyz = Pi.xyz - floor(Pi.xyz * (1.0 / 69.0)) * 69.0;
  vec3 Pi_inc1 = step(Pi, vec3(69.0 - 1.5)) * (Pi + 1.0);

  // calculate the hash
  vec4 Pt = vec4(Pi.xy, Pi_inc1.xy) + vec2(50.0, 161.0).xyxy;
  Pt *= Pt;
  Pt = Pt.xzxz * Pt.yyww;
  const vec3 SOMELARGEFLOATS = vec3(635.298681, 682.357502, 668.926525);
  const vec3 ZINC = vec3(48.500388, 65.294118, 63.934599);
  vec3 lowz_mod = vec3(1.0 / (SOMELARGEFLOATS + Pi.zzz * ZINC));
  vec3 highz_mod = vec3(1.0 / (SOMELARGEFLOATS + Pi_inc1.zzz * ZINC));
  vec4 hashx0 = fract(Pt * lowz_mod.xxxx);
  vec4 hashx1 = fract(Pt * highz_mod.xxxx);
  vec4 hashy0 = fract(Pt * lowz_mod.yyyy);
  vec4 hashy1 = fract(Pt * highz_mod.yyyy);
  vec4 hashz0 = fract(Pt * lowz_mod.zzzz);
  vec4 hashz1 = fract(Pt * highz_mod.zzzz);

  // calculate the gradients
  vec4 grad_x0 = hashx0 - 0.49999;
  vec4 grad_y0 = hashy0 - 0.49999;
  vec4 grad_z0 = hashz0 - 0.49999;
  vec4 grad_x1 = hashx1 - 0.49999;
  vec4 grad_y1 = hashy1 - 0.49999;
  vec4 grad_z1 = hashz1 - 0.49999;
  vec4 grad_results_0 = inversesqrt(grad_x0 * grad_x0 + grad_y0 * grad_y0 + grad_z0 * grad_z0) * (vec2(Pf.x, Pf_min1.x).xyxy * grad_x0 + vec2(Pf.y, Pf_min1.y).xxyy * grad_y0 + Pf.zzzz * grad_z0);
  vec4 grad_results_1 = inversesqrt(grad_x1 * grad_x1 + grad_y1 * grad_y1 + grad_z1 * grad_z1) * (vec2(Pf.x, Pf_min1.x).xyxy * grad_x1 + vec2(Pf.y, Pf_min1.y).xxyy * grad_y1 + Pf_min1.zzzz * grad_z1);

  // Classic Perlin Interpolation
  vec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);
  vec4 res0 = mix(grad_results_0, grad_results_1, blend.z);
  vec4 blend2 = vec4(blend.xy, vec2(1.0 - blend.xy));
  float final = dot(res0, blend2.zxzx * blend2.wwyy);
  return (final * 1.1547005383792515290182975610039);// scale things to a strict -1.0->1.0 range  *= 1.0/sqrt(0.75)
}

float drawNoise(in vec2 uv) {
  return 0.;
}

float noiseSpace(in vec2 st) { // normalized 0..1
  return (
    Perlin3D(
      vec3(
        st * iDrawNoiseScale - iDrawNoiseShift,
        iDrawNoisePhase
      )
    ) + 1.
  ) * .5;
}

vec2 noise2D(in vec2 st) {
  return vec2(
    Perlin3D(vec3(st * iFeedbackNoiseScale - iFeedbackNoiseShift, iFeedbackNoisePhase)),
    Perlin3D(vec3(st * iFeedbackNoiseScale + 1000. - iFeedbackNoiseShift, iFeedbackNoisePhase))
    // 1000 is an arbitrary value to sample with the same scale but starting from different coordinates, so 2 dimentions of noise differ
  ) * iFeedbackNoiseImpact;
}

void main() {
  vec2 st = (gl_FragCoord.xy * 2. - iResolution) / iMinDimension;
  if (iFeedbackNoiseImpact != 0.) {
    gl_FragColor.xy = noise2D(st);
  }
  if (iDrawNoiseApply) {
    gl_FragColor.z = noiseSpace(st);
  }
}
  </script>
  <script type="x-shader/x-fragment" id="feedback">
    precision highp float;
// no version here - we need to adhere to WebGL 1 for Apple devices, therefore only GLSL 1 syntax

// screen
uniform vec2      iResolution;
uniform float     iMinDimension;
uniform vec2      iScreenRatioHalf;

// system
uniform sampler2D iPreviousFrame;
uniform sampler2D iAudioTexture;
uniform sampler2D iNoiseTexture;

// feedback: start
uniform vec2      iFeedbackRotationCenter;
uniform float     iFeedbackRotationAngle;
uniform vec2      iFeedbackZoomCenter;
uniform float     iFeedbackZoomScale;
uniform float     iFeedbackZoomFrequencyImpact;
uniform float     iFeedbackZoomWaveformImpact;
uniform vec2      iFeedbackShiftRate;
uniform float     iFeedbackShiftFrequencyHorizontalImpact;
uniform float     iFeedbackShiftFrequencyVerticalImpact;
uniform float     iFeedbackShiftWaveformHorizontalImpact;
uniform float     iFeedbackShiftWaveformVerticalImpact;
uniform vec3      iFeedbackFadeColor;
uniform bool      iFeedbackNoiseApply;
// feedback: end

// draw noise: start
uniform bool      iDrawNoiseApply;
uniform bool      iDrawNoiseMix;
uniform float     iDrawNoiseMixFactor;
uniform vec3      iDrawNoiseColor;
uniform bool      iDrawNoiseSpectrumApply;
uniform vec3      iDrawNoiseSpectrumColor;
uniform float     iDrawNoiseSliceStart;
uniform float     iDrawNoiseSliceEnd;
uniform float     iDrawNoiseEdgeInnerStart;
uniform float     iDrawNoiseEdgeInnerEnd;
uniform float     iDrawNoiseEdgeOuterStart;
uniform float     iDrawNoiseEdgeOuterEnd;
uniform bool      iDrawNoiseSliceFrequencyApply;
uniform float     iDrawNoisePaletteIntensity;
uniform vec3      iDrawNoisePaletteA;
uniform vec3      iDrawNoisePaletteB;
uniform vec3      iDrawNoisePaletteC;
uniform vec3      iDrawNoisePaletteD;
// draw noise: end

// draw shape: start
uniform bool      iDrawShapeApply;
uniform bool      iDrawShapeMix;
uniform float     iDrawShapeMixFactor;
uniform vec3      iDrawShapeColor;
uniform bool      iDrawShapeSpectrumApply;
uniform vec3      iDrawShapeSpectrumColor;
uniform vec2      iDrawShapeCenter;
uniform float     iDrawShapeVertices;
uniform float     iDrawShapeSize;
uniform float     iDrawShapeAngle;
uniform float     iDrawShapeSliceStart;
uniform float     iDrawShapeSliceEnd;
uniform float     iDrawShapeEdgeInnerStart;
uniform float     iDrawShapeEdgeInnerEnd;
uniform float     iDrawShapeEdgeOuterStart;
uniform float     iDrawShapeEdgeOuterEnd;
uniform bool      iDrawShapeFrequencyApply;
uniform bool      iDrawShapeSliceFrequencyApply;
uniform float     iDrawShapePaletteIntensity;
uniform vec3      iDrawShapePaletteA;
uniform vec3      iDrawShapePaletteB;
uniform vec3      iDrawShapePaletteC;
uniform vec3      iDrawShapePaletteD;
// draw shape: end


const float PI = 3.14159265359;
const float TWO_PI = 6.28318530718;

const float AUDIO_SIGNAL_COUNT = 9.;

#define getAudioSignalPosition(i) (float(i) / AUDIO_SIGNAL_COUNT + .5 / AUDIO_SIGNAL_COUNT)

const float FEEDBACK_ZOOM_FREQUENCY             = getAudioSignalPosition(0);
const float FEEDBACK_ZOOM_WAVEFORM              = getAudioSignalPosition(1);
const float FEEDBACK_SHIFT_FREQUENCY_HORIZONTAL = getAudioSignalPosition(2);
const float FEEDBACK_SHIFT_FREQUENCY_VERTICAL   = getAudioSignalPosition(3);
const float FEEDBACK_SHIFT_WAVEFORM_HORIZONTAL  = getAudioSignalPosition(4);
const float FEEDBACK_SHIFT_WAVEFORM_VERTICAL    = getAudioSignalPosition(5);
const float DRAW_SHAPE_FREQUENCY                = getAudioSignalPosition(6);
const float DRAW_SHAPE_SLICE_FREQUENCY          = getAudioSignalPosition(7);
const float DRAW_NOISE_SLICE_FREQUENCY          = getAudioSignalPosition(8);

// -- Libs: Start

// Spectral Colour Schemes
// By Alan Zucconi
// Website: www.alanzucconi.com
// Twitter: @AlanZucconi

// Example of different spectral colour schemes
// to convert visible wavelengths of light (400-700 nm) to RGB colours.

// The function "spectral_zucconi6" provides the best approximation
// without including any branching.
// Its faster version, "spectral_zucconi", is advised for mobile applications.


// Read "Improving the Rainbow" for more information
// http://www.alanzucconi.com/?p=6703

float saturate (float x)
{
  return min(1.0, max(0.0, x));
}
vec3 saturate (vec3 x)
{
  return min(vec3(1., 1., 1.), max(vec3(0., 0., 0.), x));
}

// --- Spectral Zucconi --------------------------------------------
// By Alan Zucconi
// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html
// But with values optimised to match as close as possible the visible spectrum
// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg
// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)
vec3 bump3y (vec3 x, vec3 yoffset)
{
  vec3 y = vec3(1., 1., 1.) - x * x;
  y = saturate(y-yoffset);
  return y;
}

// --- Spectral Zucconi 6 --------------------------------------------

// Based on GPU Gems
// Optimised by Alan Zucconi
vec3 spectral_zucconi6 (float x)
{
  const vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);
  const vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);
  const vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);

  const vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);
  const vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);
  const vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);

  return bump3y(c1 * (x - x1), y1) + bump3y(c2 * (x - x2), y2);
}

mat2 rotate2d(in float angle){
  return mat2(cos(angle),-sin(angle),
  sin(angle),cos(angle));
}

// from: https://iquilezles.org/www/articles/palettes/palettes.htm
vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {
  return a + b * cos( TWO_PI * (c*t+d) );
}

// -- Libs: End

float map(in float value, in float min1, in float max1, in float min2, in float max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

float mapFrom01(in float value, in float min, in float max) {
  return min + value * (max - min);
}

float mapTo01(in float value, in float min, in float max) {
  return (value - min) / (max - min);
}

/*
  Normally it would be provided by texture parameters, but on iOS the texture REPEAT works only
  for textures which size is the power of 2.
 */
vec4 repeatedTexture(in sampler2D channel, in vec2 uv) {
  return texture2D(channel, mod(uv, 1.));
}

float getAudio(in float signal, in float x) {
  return texture2D(iAudioTexture, vec2(x, signal)).r;
}

float sdPolygon(in float angle, in float distance) {
  float segment = TWO_PI / iDrawShapeVertices;
  return cos(floor(.5 + angle / segment) * segment - angle) * distance;
}

float shapeSpace(in vec2 st) {
  float drawAngle = atan(st.x, st.y);
  float drawFreq = (drawAngle) / -TWO_PI;
  float dist = length(st) / iDrawShapeSize;
  if (iDrawShapeVertices > 1.) {
    dist = sdPolygon(drawAngle - iDrawShapeAngle, dist);
  }
  if (iDrawShapeFrequencyApply) {
    dist -= getAudio(DRAW_SHAPE_FREQUENCY, drawFreq);
  }
  return dist;
}

vec4 draw(
  in float space,
  in float sliceStart,
  in float sliceEnd,
  in float innerEdgeStart,
  in float innerEdgeEnd,
  in float outerEdgeStart,
  in float outerEdgeEnd,
  in vec3  color,
  in bool  applySpectrum,
  in vec3  spectrumColor,
  in bool  applyFrequency,
  in float frequencySource,
  in float paletteIntensity,
  in vec3  paletteA,
  in vec3  paletteB,
  in vec3  paletteC,
  in vec3  paletteD
) {

  float shape = clamp(mapTo01(space, sliceStart, sliceEnd), 0., 1.);

  float shapeMap =
    (1. - smoothstep(innerEdgeEnd, innerEdgeStart, space))
    * smoothstep(outerEdgeEnd, outerEdgeStart, space);

  vec3 shapeColor = color * shapeMap;

  if (applySpectrum) {
    shapeColor += spectral_zucconi6(shape) * spectrumColor;
  }

  if (paletteIntensity > 0.) {
    shapeColor += palette(
      shape,
      paletteA,
      paletteB,
      paletteC,
      paletteD
    ) * paletteIntensity;
  }

  if (applyFrequency) {
    shapeColor *= getAudio(frequencySource, shape);
  }

  return vec4(shapeColor, shapeMap);
}

void main() {
  vec2 uv = gl_FragCoord.xy / iResolution;
  vec2 st = (gl_FragCoord.xy * 2. - iResolution) / iMinDimension;

  vec2 feedbackSt = st;
  if (iFeedbackRotationAngle != 0.) {
    feedbackSt -= iFeedbackRotationCenter;
    feedbackSt *= rotate2d(iFeedbackRotationAngle);
    feedbackSt += iFeedbackRotationCenter;
  }

  vec2 zoomSt = feedbackSt - iFeedbackZoomCenter;
  vec2 zoomShift = zoomSt;
  zoomShift *= iFeedbackZoomScale;
  feedbackSt -= zoomShift;
  float zoomAngle = atan(zoomSt.x, zoomSt.y);
  float zoomFreq = (zoomAngle) / - TWO_PI;

  if (iFeedbackZoomFrequencyImpact != 0.) {
    feedbackSt -= zoomSt * getAudio(FEEDBACK_ZOOM_FREQUENCY, zoomFreq);
  }

  if (iFeedbackZoomWaveformImpact != 0.) {
    feedbackSt -= zoomSt * getAudio(FEEDBACK_ZOOM_WAVEFORM, zoomFreq);
  }

  feedbackSt -= iFeedbackShiftRate;

  if (iFeedbackShiftFrequencyHorizontalImpact != 0.) {
    feedbackSt -= vec2(getAudio(FEEDBACK_SHIFT_FREQUENCY_HORIZONTAL, uv.y), 0);
  }

  if (iFeedbackShiftFrequencyVerticalImpact != 0.) {
    feedbackSt -= vec2(0, getAudio(FEEDBACK_SHIFT_FREQUENCY_VERTICAL, uv.x));
  }

  if (iFeedbackShiftWaveformHorizontalImpact != 0.) {
    feedbackSt -= vec2(getAudio(FEEDBACK_SHIFT_WAVEFORM_HORIZONTAL, uv.y), 0);
  }

  if (iFeedbackShiftWaveformVerticalImpact != 0.) {
    feedbackSt -= vec2(0, getAudio(FEEDBACK_SHIFT_WAVEFORM_VERTICAL, uv.x));
  }

  if (iFeedbackNoiseApply) {
    feedbackSt += texture2D(iNoiseTexture, uv).xy;
  }

  vec2 feedbackUv = feedbackSt * iScreenRatioHalf - .5;

  vec3 color = repeatedTexture(iPreviousFrame, feedbackUv).rgb;
  color *= iFeedbackFadeColor;

  if (iDrawNoiseApply) {
    vec4 drawColor = draw(
      texture2D(iNoiseTexture, uv).z,
      iDrawNoiseSliceStart,
      iDrawNoiseSliceEnd,
      iDrawNoiseEdgeInnerStart,
      iDrawNoiseEdgeInnerEnd,
      iDrawNoiseEdgeOuterStart,
      iDrawNoiseEdgeOuterEnd,
      iDrawNoiseColor,
      iDrawNoiseSpectrumApply,
      iDrawNoiseSpectrumColor,
      iDrawNoiseSliceFrequencyApply,
      DRAW_NOISE_SLICE_FREQUENCY,
      iDrawNoisePaletteIntensity,
      iDrawNoisePaletteA,
      iDrawNoisePaletteB,
      iDrawNoisePaletteC,
      iDrawNoisePaletteD
    );
    color = iDrawNoiseMix
      ? mix(color, drawColor.rgb, drawColor.a * iDrawNoiseMixFactor)
      : color + drawColor.rgb * drawColor.a;
  }

  if (iDrawShapeApply) {
    vec4 drawColor = draw(
      shapeSpace(st - iDrawShapeCenter),
      iDrawShapeSliceStart,
      iDrawShapeSliceEnd,
      iDrawShapeEdgeInnerStart,
      iDrawShapeEdgeInnerEnd,
      iDrawShapeEdgeOuterStart,
      iDrawShapeEdgeOuterEnd,
      iDrawShapeColor,
      iDrawShapeSpectrumApply,
      iDrawShapeSpectrumColor,
      iDrawShapeSliceFrequencyApply,
      DRAW_SHAPE_SLICE_FREQUENCY,
      iDrawShapePaletteIntensity,
      iDrawShapePaletteA,
      iDrawShapePaletteB,
      iDrawShapePaletteC,
      iDrawShapePaletteD
    );
    color = iDrawShapeMix
      ? mix(color, drawColor.rgb, drawColor.a * iDrawShapeMixFactor)
      : color + drawColor.rgb * drawColor.a;
  }

  color = clamp(color, 0., 1.);
  gl_FragColor = vec4(color, 1);
}
  </script>
  <script type="x-shader/x-fragment" id="image">
    precision highp float;
// no version here - we need to adhere to WebGL 1 for Apple devices, therefore only GLSL 1 syntax

// screen
uniform vec2      iResolution;
uniform float     iMinDimension;
uniform vec2      iScreenRatioHalf;

// color
uniform float     iColorGammaCorrection;
uniform bool      iColorInvert;

// post-processing
uniform float     iRippleImpact;
uniform vec2      iRippleCenter;
uniform float     iRippleScale;
uniform float     iRipplePhase;

// glass
uniform bool      iGlassApply;
uniform float     iGlassRefraction;
uniform float     iGlassColorImpact;
uniform vec3      iGlassColorBase;
uniform vec3      iGlassColorTint;
uniform vec2      iGlassCenter;
uniform float     iGlassVertices;
uniform float     iGlassWidth;
uniform float     iGlassEdgeWidth;
uniform float     iGlassEdgeThickness;
uniform float     iGlassEdgeSmoothing;
uniform float     iGlassAngle;
uniform float     iGlassPhase;
uniform float     iGlassFade;
uniform bool      iGlassPerspective;
uniform float     iGlassScale;



// textures
uniform sampler2D iFeedbackTexture; // previous frame

// gamma

const float PI = 3.14159265359;
const float TWO_PI = 6.28318530718;

float sdPolygon(in float angle, in float distance) {
  float segment = TWO_PI / iGlassVertices;
  return cos(floor(.5 + angle / segment) * segment - angle) * distance;
}

vec2 rippleShift(in vec2 st) {
  float dist = length(iRippleCenter - st);
  return (sin(dist * iRippleScale - iRipplePhase) + 1.) * iRippleImpact * st;
}

float glassShapeMap(in float modGlassSpaceReverse) {
  return smoothstep(0., iGlassEdgeSmoothing, modGlassSpaceReverse)
    * smoothstep(iGlassWidth, iGlassWidth - iGlassEdgeSmoothing, modGlassSpaceReverse);
}

float glassEdgeMap(in float modGlassSpace, in float modGlassSpaceReverse) {
  float bumpMap = sin(modGlassSpace * TWO_PI / iGlassEdgeWidth)
    * step(modGlassSpaceReverse, iGlassEdgeWidth);
  bumpMap += sin((iGlassWidth + modGlassSpaceReverse) * TWO_PI / iGlassEdgeWidth)
    * step(iGlassWidth - iGlassEdgeWidth, modGlassSpaceReverse)
    * step(1. - iGlassWidth, modGlassSpace);
  return bumpMap;
}

void main() {
  vec2 uv = gl_FragCoord.xy / iResolution.xy;
  vec2 st = (gl_FragCoord.xy * 2. - iResolution) / iMinDimension;

  vec2 shift = vec2(0);

  float glassColorImpact = 0.;

  shift += rippleShift(st);

  if (iGlassApply) {
    vec2 glassSt = st - iGlassCenter;
    float glassAngle = atan(glassSt.x, glassSt.y) - iGlassAngle;
    float glassDistance = length(glassSt);
    if (iGlassVertices > 1.) {
      glassDistance = sdPolygon(glassAngle, glassDistance);
    }
    float glassSpace = glassDistance;

    if (iGlassPerspective) {
      glassSpace = - iGlassScale / glassSpace; // minus applied to keep the direction of glassSpeed
    } else {
      glassSpace *= iGlassScale;
    }

    float modGlassSpace = mod(glassSpace - iGlassPhase, 1.);
    float modGlassSpaceReverse = 1. - modGlassSpace;

    float perspectiveFade = smoothstep(0., iGlassFade, glassDistance);
    float shapeMap = glassShapeMap(modGlassSpaceReverse);
    float glassEdgeMap = glassEdgeMap(modGlassSpace, modGlassSpaceReverse) * shapeMap;
    float glassMap = (shapeMap + glassEdgeMap * iGlassEdgeThickness);
    shift += glassMap * st * iGlassRefraction * perspectiveFade;
    glassColorImpact = iGlassColorImpact * shapeMap * perspectiveFade;
  }

  vec3 color = texture2D(iFeedbackTexture, uv - shift * iScreenRatioHalf).rgb;

  if (iGlassApply) {
    color = mix(color, iGlassColorBase + color * iGlassColorTint, glassColorImpact);
  }

  // TODO maybe we should invert this order?
  color = pow(color, vec3(1. / iColorGammaCorrection));
  if (iColorInvert) {
    color = 1. - color;
  }

  gl_FragColor = vec4(color, 1.);
}
  </script>
  <script>
    (() => {

      Element.prototype.also = function(block) {
  block(this);
  return this;
};

Element.prototype.run = function(block) {
  return block(this);
}

Element.prototype.appendChildren = function(children) {
  children.forEach(child => this.appendChild(child));
}

const toArray = (object, block) =>
  Object.keys(object).map((key) => block(key, object[key]));

const getElement = (id) => document.getElementById(id);

const newElement = (type, className) =>
  document.createElement(type).also((it) => {
    if (className) {
      it.className = className;
    }
  });

function when(eventTarget, eventType, handler) {
  if (eventTarget instanceof EventTarget) {
    eventTarget.addEventListener(eventType, handler)
  } else if (typeof eventTarget === "string") {
    const element = getElement(eventTarget);
    if (element) {
      element.addEventListener(eventType, handler)
    } else {
      throw "Cannot find Element of given id: " + eventTarget;
    }
  } else {
    throw "eventTarget must be instance of EventTarget or string denoting";
  }
}

function getFunctionBody(func) {
  const source = func.toString();
  body = source.slice(source.indexOf("{") + 1, source.lastIndexOf("}"));
  if (body.startsWith("\n")) {
    body = body.slice(1);
  }
  return body;
}
      const newBlockElement = (name, className, content) => newElement(name, className, content).also((it) => {
  if (content) {
    (content instanceof Array)
      ? it.appendChildren(content)
      : it.innerText = content;
  }
});

const div = (className, content) => newBlockElement("div", className, content);

const span = (className, content) => newBlockElement("span", className, content);

const slider = (min, max, step) => newElement("input").also((it) => {
  it.className = "slider";
  it.type = "range";
  it.step = step ? step : "any";
  it.min = min;
  it.max = max;
});

const formatNumber = (x) => Number(x).toFixed(4);

function checkbox(elementId, block) {
  when(elementId, "change", (event) => {
    block(event.target.checked);
  });
}

const details = (summary, content) => newElement("details").also((details) => {
  details.appendChild(
    newElement("summary").also((it) => it.innerText = summary)
  );
  if (content) {
    details.appendChild(content);
  }
});

const option = (value, label) => newElement("option").also((it) => {
  it.value = value;
  it.innerText = label;
});
      // TODO move webgl utils to separate file
// Taken from: https://github.com/mrdoob/three.js/blob/dev/src/extras/DataUtils.js
const _floatView = new Float32Array(1);
const _int32View = new Int32Array(_floatView.buffer);

function toHalfFloat(val) {
  if ( val > 65504 ) {
    val = 65504; // maximum representable value in float16
  }

  // Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410

  /* This method is faster than the OpenEXR implementation (very often
   * used, eg. in Ogre), with the additional benefit of rounding, inspired
   * by James Tursa?s half-precision code. */

	_floatView[0] = val;
	const x = _int32View[0];

	let bits = ( x >> 16 ) & 0x8000; /* Get the sign */
	let m = ( x >> 12 ) & 0x07ff; /* Keep one extra bit for rounding */
	const e = ( x >> 23 ) & 0xff; /* Using int is faster here */

	/* If zero, or denormal, or exponent underflows too much for a denormal
	 * half, return signed zero. */
	if ( e < 103 ) return bits;

  /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */
  if ( e > 142 ) {

    bits |= 0x7c00;
    /* If exponent was 0xff and one mantissa bit was set, it means NaN,
          * not Inf, so make sure we set one mantissa bit too. */
    bits |= ( ( e == 255 ) ? 0 : 1 ) && ( x & 0x007fffff );
    return bits;

  }

  /* If exponent underflows but not too much, return a denormal */
  if ( e < 113 ) {

    m |= 0x0800;
    /* Extra rounding may overflow and set mantissa to 0 and exponent
      * to 1, which is OK. */
    bits |= ( m >> ( 114 - e ) ) + ( ( m >> ( 113 - e ) ) & 1 );
    return bits;

  }

  bits |= ( ( e - 112 ) << 10 ) | ( m >> 1 );
  /* Extra rounding. An overflow will set mantissa to 0 and increment
    * the exponent, which is OK. */
  bits += m & 1;
  return bits;

}

const DEFAULT_FREQUENCY_BIN_COUNT = 1024;
const DEFAULT_WAVEFORM_SIZE = 2048;

class AudioDataRenderer {

  constructor(gl) {
    this.leftFrequencies = new TextureRenderer(gl, DEFAULT_FREQUENCY_BIN_COUNT, -100); // default web audio analyser size, half of 2048 - default fft size
    this.rightFrequencies = new TextureRenderer(gl, DEFAULT_FREQUENCY_BIN_COUNT, -100);
    this.waveform = new TextureRenderer(gl, DEFAULT_WAVEFORM_SIZE, 0); // in case of waveform it's divided by 2
    this.renderers = [
      this.leftFrequencies,
      this.rightFrequencies,
      this.waveform
    ];
  }

  render() {
    this.renderers.forEach(renderer => renderer.render());
  }

  resize(frequencySize, waveformSize) {
    this.leftFrequencyRenderer.resize(frequencySize);
    this.rightFrequencyRenderer.resize(frequencySize);
    this.waveformRenderer.resize(waveformSize);
  }

}

class TextureRenderer {

  constructor(gl, size, initialValue) {
    this.texture = new AudioTexture(gl);
    this.size = size;
    this.initialValue = initialValue;
    this.resize(size);
  }

  resize(size) {
    this.size = size;
    this.data = new Float32Array(size);
    this.data.fill(this.initialValue);
    this.texture.setSize(size);
  }

  getTexture() {
    return this.texture.texture;
  }

  render() {
    this.texture.render(this.data);
  }

}

class AudioTexture {

  constructor(gl) {
    this.gl = gl;
    if (gl.constructor.name === "WebGL2RenderingContext") {
      this.internalformat = gl.RGBA16F;
      this.format = gl.HALF_FLOAT;
    } else {
      const ext = gl.getExtension("OES_texture_half_float");
      this.internalformat = gl.RGBA;
      this.format = ext.HALF_FLOAT_OES;
    }
  }

  setSize(size) {
    const gl = this.gl;

    if (this.texture) {
      gl.deleteTexture(this.texture);
    }

    this.size = size;
    this.textureSize = size * 4; // for now encoded as RGBA
    this.audioPixels = new Uint16Array(this.textureSize);
    this.texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texImage2D(
      gl.TEXTURE_2D,
      0,
      this.internalformat,
      size,
      1,
      0,
      gl.RGBA,
      this.format,
      this.audioPixels
    );
    gl.bindTexture(gl.TEXTURE_2D, null);
  }

  // TODO optimize to store only RED for audio texture
  render(data) {
    let offset = 0;
    for (let i = 0; i < data.length; i++) {
      const value = data[i];
      const halfFloat = toHalfFloat(value);
      for (let j = 0; j < 3; j++) {
        this.audioPixels[offset++] = halfFloat;
      }
      this.audioPixels[offset++] = toHalfFloat(1); // TODO change to const
    }
    const gl = this.gl;
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.texSubImage2D(
      gl.TEXTURE_2D,
      0,
      0,
      0,
      this.size,
      1,
      gl.RGBA,
      this.format,
      this.audioPixels
    );
    gl.bindTexture(gl.TEXTURE_2D, null);
  }

}

      const visualizer = (() => {
        const PI = Math.PI;
const TWO_PI = 2 * PI;
const GOLDEN_RATIO = .61803398875;

const min = Math.min;
const max = Math.max;
const sin = Math.sin;
const cos = Math.cos;
const pow = Math.pow;
const floor = Math.floor;

const fract = (x) => x % 1;

function smoothstep(min, max, value) {
  const x = Math.max(0, Math.min(1, (value - min) / (max - min)));
  return x * x * (3 - 2 * x);
}

const mix = (x, y, a) => x * (1 - a) + y * a;

const rand = (x) => fract(Math.sin(x) * 100000);

const toRadians = (degrees) => degrees * (PI / 180);

// spectral_zucconi6 by Alan Zucconi rewritten from GLSL to JS by Kazik Pogoda
// GLSL: https://www.shadertoy.com/view/ls2Bz1

const ONE_IN_3D = [1, 1, 1];

const saturate = (x) => min(max(x, 0), 1);
const toVector2 = (x) => [x, x];
const toVector3 = (x) => [x, x, x];
const pow2Vectors = (x) => multiplyVectors(x, x);
const saturateVectors = (x) => x.map((xi) => saturate(xi));
const bump3y = (x, yoffset) => saturateVectors(subtractVectors(subtractVectors(ONE_IN_3D, pow2Vectors(x)), yoffset));
const addVectors = (x, y) => x.map((xi, i) => xi + y[i]);
const subtractVectors = (x, y) => x.map((xi, i) => xi - y[i]);
const multiplyVectors = (x, y) => x.map((xi, i) => xi * y[i]);
const isZeroVector = (x) => (x.reduce((accumulator, xi) => accumulator + xi, 0) === 0);
const cosVector = (x) => x.map((xi) => cos(xi));

const wave = (x) => (cos(x) + 1) / 2;

const quilezPalette = (t, a, b, c, d) => addVectors(
  a,
  multiplyVectors(
    b,
    cosVector(
      multiplyVectors(
        toVector3(TWO_PI),
        addVectors(
          multiplyVectors(c, toVector3(t)),
          d
        )
      )
    )
  )
);

// Function from Iñigo Quiles
// www.iquilezles.org/www/articles/functions/functions.htm
function impulse(k, x) {
  const h = k * x;
  return h * Math.exp(1 - h);
}

// Borrowed from Alan Zucconi
// https://www.alanzucconi.com/2017/07/15/improving-the-rainbow/
const spectralColor = (() => {

  const zucconi = {
    c1: [3.54585104, 2.93225262, 2.41593945],
    x1: [0.69549072, 0.49228336, 0.27699880],
    y1: [0.02312639, 0.15225084, 0.52607955],
    c2: [3.90307140, 3.21182957, 3.96587128],
    x2: [0.11748627, 0.86755042, 0.66077860],
    y2: [0.84897130, 0.88445281, 0.73949448],
  }

  return (x) => addVectors(
    bump3y(
      multiplyVectors(
        zucconi.c1,
        subtractVectors(toVector3(x), zucconi.x1)
      ),
      zucconi.y1
    ),
    bump3y(
      multiplyVectors(
        zucconi.c2,
        subtractVectors(toVector3(x), zucconi.x2)
      ),
      zucconi.y2
    )
  )
})();

// TODO needs adjustment to new API and extracting math part and experience part
/*
const vectorPolynomial =
  (componentPolynomials) =>
    (x) => componentPolynomials.map((polynomial) => polynomial(x));

const calculateVectorInterpolatingPolynomial = (levels, property) =>
  vectorPolynomial(
    levels[0][property].map((component, componentIndex) =>
      interpolatingPolynomial(
        levels.map((level, index) => [index / levels.length, level[property][componentIndex]])
      )
    )
  );

const calculateInterpolatingPolynomial = (levels, property) =>
  (levels[0][property] instanceof Array)
    ? calculateVectorInterpolatingPolynomial(levels, property)
    : interpolatingPolynomial(
      levels.map((level, index) => [index / levels.length, level[property]])
    );

function calculateInterpolatingPolynomials(levels) {
  const polynomials = {};
  for (const property in levels[0]) {
    polynomials[property] = calculateInterpolatingPolynomial(levels, property);
  }
  return polynomials;
}

function setLevelIntensity(x) {
  for (const property in controls) {
    controls[property] = polynomials[property](x);
  }
}

const interpolatingPolynomial = (points) => {
  const n = points.length - 1;
  const p = (i, j, x) =>
    (i === j)
      ? points[i][1]
      : (
          (
            (points[j][0] - x) * p(i, j - 1, x)
            + (x - points[i][0]) * p(i + 1, j, x)
          )
          / (points[j][0] - points[i][0])
      );

  return (x) => (points.length === 0) ? 0 : p(0, n, x);
};

*/
        // taken from:
// https://github.com/processing/p5.js/blob/374acfb44588bfd565c54d61264df197d798d121/src/math/noise.js
// the original file slightly altered

const noise = (() => {

const PERLIN_YWRAPB = 4;
const PERLIN_YWRAP = 1 << PERLIN_YWRAPB;
const PERLIN_ZWRAPB = 8;
const PERLIN_ZWRAP = 1 << PERLIN_ZWRAPB;
const PERLIN_SIZE = 4095;

let perlin_octaves = 4; // default to medium smooth
let perlin_amp_falloff = 0.5; // 50% reduction/octave

const scaled_cosine = i => 0.5 * (1.0 - Math.cos(i * Math.PI));

let perlin; // will be initialized lazily by noise() or noiseSeed()

/**
 * Returns the Perlin noise value at specified coordinates. Perlin noise is
 * a random sequence generator producing a more naturally ordered, harmonic
 * succession of numbers compared to the standard <b>random()</b> function.
 * It was invented by Ken Perlin in the 1980s and been used since in
 * graphical applications to produce procedural textures, natural motion,
 * shapes, terrains etc.<br /><br /> The main difference to the
 * <b>random()</b> function is that Perlin noise is defined in an infinite
 * n-dimensional space where each pair of coordinates corresponds to a
 * fixed semi-random value (fixed only for the lifespan of the program; see
 * the <a href="#/p5/noiseSeed">noiseSeed()</a> function). p5.js can compute 1D, 2D and 3D noise,
 * depending on the number of coordinates given. The resulting value will
 * always be between 0.0 and 1.0. The noise value can be animated by moving
 * through the noise space as demonstrated in the example above. The 2nd
 * and 3rd dimension can also be interpreted as time.<br /><br />The actual
 * noise is structured similar to an audio signal, in respect to the
 * function's use of frequencies. Similar to the concept of harmonics in
 * physics, perlin noise is computed over several octaves which are added
 * together for the final result. <br /><br />Another way to adjust the
 * character of the resulting sequence is the scale of the input
 * coordinates. As the function works within an infinite space the value of
 * the coordinates doesn't matter as such, only the distance between
 * successive coordinates does (eg. when using <b>noise()</b> within a
 * loop). As a general rule the smaller the difference between coordinates,
 * the smoother the resulting noise sequence will be. Steps of 0.005-0.03
 * work best for most applications, but this will differ depending on use.
 *
 * @method noise
 * @param  {Number} x   x-coordinate in noise space
 * @param  {Number} [y] y-coordinate in noise space
 * @param  {Number} [z] z-coordinate in noise space
 * @return {Number}     Perlin noise value (between 0 and 1) at specified
 *                      coordinates
 * @example
 * <div>
 * <code>
 * let xoff = 0.0;
 *
 * function draw() {
 *   background(204);
 *   xoff = xoff + 0.01;
 *   let n = noise(xoff) * width;
 *   line(n, 0, n, height);
 * }
 * </code>
 * </div>
 * <div>
 * <code>let noiseScale=0.02;
 *
 * function draw() {
 *   background(0);
 *   for (let x=0; x < width; x++) {
 *     let noiseVal = noise((mouseX+x)*noiseScale, mouseY*noiseScale);
 *     stroke(noiseVal*255);
 *     line(x, mouseY+noiseVal*80, x, height);
 *   }
 * }
 * </code>
 * </div>
 *
 * @alt
 * vertical line moves left to right with updating noise values.
 * horizontal wave pattern effected by mouse x-position & updating noise values.
 */

const p5jsNoise = function(x, y = 0, z = 0) {
  if (perlin == null) {
    perlin = new Array(PERLIN_SIZE + 1);
    for (let i = 0; i < PERLIN_SIZE + 1; i++) {
      perlin[i] = Math.random();
    }
  }

  if (x < 0) {
    x = -x;
  }
  if (y < 0) {
    y = -y;
  }
  if (z < 0) {
    z = -z;
  }

  let xi = Math.floor(x),
    yi = Math.floor(y),
    zi = Math.floor(z);
  let xf = x - xi;
  let yf = y - yi;
  let zf = z - zi;
  let rxf, ryf;

  let r = 0;
  let ampl = 0.5;

  let n1, n2, n3;

  for (let o = 0; o < perlin_octaves; o++) {
    let of = xi + (yi << PERLIN_YWRAPB) + (zi << PERLIN_ZWRAPB);

    rxf = scaled_cosine(xf);
    ryf = scaled_cosine(yf);

    n1 = perlin[of & PERLIN_SIZE];
    n1 += rxf * (perlin[(of + 1) & PERLIN_SIZE] - n1);
    n2 = perlin[(of + PERLIN_YWRAP) & PERLIN_SIZE];
    n2 += rxf * (perlin[(of + PERLIN_YWRAP + 1) & PERLIN_SIZE] - n2);
    n1 += ryf * (n2 - n1);

    of += PERLIN_ZWRAP;
    n2 = perlin[of & PERLIN_SIZE];
    n2 += rxf * (perlin[(of + 1) & PERLIN_SIZE] - n2);
    n3 = perlin[(of + PERLIN_YWRAP) & PERLIN_SIZE];
    n3 += rxf * (perlin[(of + PERLIN_YWRAP + 1) & PERLIN_SIZE] - n3);
    n2 += ryf * (n3 - n2);

    n1 += scaled_cosine(zf) * (n2 - n1);

    r += n1 * ampl;
    ampl *= perlin_amp_falloff;
    xi <<= 1;
    xf *= 2;
    yi <<= 1;
    yf *= 2;
    zi <<= 1;
    zf *= 2;

    if (xf >= 1.0) {
      xi++;
      xf--;
    }
    if (yf >= 1.0) {
      yi++;
      yf--;
    }
    if (zf >= 1.0) {
      zi++;
      zf--;
    }
  }
  return r;
};

/**
 *
 * Adjusts the character and level of detail produced by the Perlin noise
 * function. Similar to harmonics in physics, noise is computed over
 * several octaves. Lower octaves contribute more to the output signal and
 * as such define the overall intensity of the noise, whereas higher octaves
 * create finer grained details in the noise sequence.
 *
 * By default, noise is computed over 4 octaves with each octave contributing
 * exactly half than its predecessor, starting at 50% strength for the 1st
 * octave. This falloff amount can be changed by adding an additional function
 * parameter. Eg. a falloff factor of 0.75 means each octave will now have
 * 75% impact (25% less) of the previous lower octave. Any value between
 * 0.0 and 1.0 is valid, however note that values greater than 0.5 might
 * result in greater than 1.0 values returned by <b>noise()</b>.
 *
 * By changing these parameters, the signal created by the <b>noise()</b>
 * function can be adapted to fit very specific needs and characteristics.
 *
 * @method noiseDetail
 * @param {Number} lod number of octaves to be used by the noise
 * @param {Number} falloff falloff factor for each octave
 * @example
 * <div>
 * <code>
 * let noiseVal;
 * let noiseScale = 0.02;
 *
 * function setup() {
 *   createCanvas(100, 100);
 * }
 *
 * function draw() {
 *   background(0);
 *   for (let y = 0; y < height; y++) {
 *     for (let x = 0; x < width / 2; x++) {
 *       noiseDetail(2, 0.2);
 *       noiseVal = noise((mouseX + x) * noiseScale, (mouseY + y) * noiseScale);
 *       stroke(noiseVal * 255);
 *       point(x, y);
 *       noiseDetail(8, 0.65);
 *       noiseVal = noise(
 *         (mouseX + x + width / 2) * noiseScale,
 *         (mouseY + y) * noiseScale
 *       );
 *       stroke(noiseVal * 255);
 *       point(x + width / 2, y);
 *     }
 *   }
 * }
 * </code>
 * </div>
 *
 * @alt
 * 2 vertical grey smokey patterns affected my mouse x-position and noise.
 */
const noiseDetail = function(lod, falloff) {
  if (lod > 0) {
    perlin_octaves = lod;
  }
  if (falloff > 0) {
    perlin_amp_falloff = falloff;
  }
};

/**
 * Sets the seed value for <b>noise()</b>. By default, <b>noise()</b>
 * produces different results each time the program is run. Set the
 * <b>value</b> parameter to a constant to return the same pseudo-random
 * numbers each time the software is run.
 *
 * @method noiseSeed
 * @param {Number} seed   the seed value
 * @example
 * <div>
 * <code>let xoff = 0.0;
 *
 * function setup() {
 *   noiseSeed(99);
 *   stroke(0, 10);
 * }
 *
 * function draw() {
 *   xoff = xoff + .01;
 *   let n = noise(xoff) * width;
 *   line(n, 0, n, height);
 * }
 * </code>
 * </div>
 *
 * @alt
 * vertical grey lines drawing in pattern affected by noise.
 */
 const noiseSeed = function(seed) {
  // Linear Congruential Generator
  // Variant of a Lehman Generator
  const lcg = (() => {
    // Set to values from http://en.wikipedia.org/wiki/Numerical_Recipes
    // m is basically chosen to be large (as it is the max period)
    // and for its relationships to a and c
    const m = 4294967296;
    // a - 1 should be divisible by m's prime factors
    const a = 1664525;
    // c and m should be co-prime
    const c = 1013904223;
    let seed, z;
    return {
      setSeed(val) {
        // pick a random seed if val is undefined or null
        // the >>> 0 casts the seed to an unsigned 32-bit integer
        z = seed = (val == null ? Math.random() * m : val) >>> 0;
      },
      getSeed() {
        return seed;
      },
      rand() {
        // define the recurrence relationship
        z = (a * z + c) % m;
        // return a float in [0, 1)
        // if z = m then z / m = 0 therefore (z % m) / m < 1 always
        return z / m;
      }
    };
  })();

  lcg.setSeed(seed);
  perlin = new Array(PERLIN_SIZE + 1);
  for (let i = 0; i < PERLIN_SIZE + 1; i++) {
    perlin[i] = lcg.rand();
  }
};

  return p5jsNoise;
})();
        const SHOW_AS_FREQUENCY = (x) => Number(x * 22.05).toFixed(1) + " kHz";
const SHOW_AS_DECIBELS = (x) => Number(x).toFixed(1) + " dB";
const SHOW_AS_DEGREES = (x) => Number(x).toFixed(1) + "°";

const controlsMetadata = {
  analyser: {
    frequency: {
      samples:                  ["integer", 4, 14, 10, "the window size in samples that is used when performing a Fast Fourier Transform (FFT) to get frequency domain data, see: https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/fftSize", x => Math.pow(2, x)],
      stereo:                   ["boolean", true],
      smoothing:                [0, 1, 0.8,     "an average between the current FFT analysis data and the last FFT analysis data"],
      logScale:                 ["boolean", false, "here only for visualization purposes"]
    },
    waveform: {
      samples:                  ["integer", 5, 15, 11, "the window size in samples that is used when performing a Fast Fourier Transform (FFT) to get frequency domain data, see: https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/fftSize", x => Math.pow(2, x)]
    }
  },
  color: {
    gammaCorrection:            [0, 5, 1],
    invert:                     ["boolean", false],
  },
  feedback: {
    fade: {
      rate:                     [0, 2, .95, "How fast the previous frame will loose it's intensity - usually something just below 1, Note: adjusting this setting should usually follow draw.x.intensity counter-adjustment"],
      color:                    ["color", [1, 1, 1] ],
    },
    rotation: {
      center:                   [ [-10, -10], [10, 10], [0, 0] ],
      angle:                    [-360, 360, 0, "Feedback rotation angle", SHOW_AS_DEGREES]
    },
    zoom: {
      center:                   [ [-10, -10], [10, 10], [0, 0] ],
      scale:                    [0, 10, 1],
      frequency: {
        impact:                 [-1, 1, 0],
        range: {
          min:                  [0, 1, 0, "in hertz", SHOW_AS_FREQUENCY],
          max:                  [0, 1, 1, "in hertz", SHOW_AS_FREQUENCY],
          logScale:             ["boolean", false],
        },
        loudness: {
          min:                  [-100, 0, -100, "minimum decibel value for scaling the FFT analysis data, where 0 dB is the loudest possible sound, -10 dB is a 10th of that, etc.", SHOW_AS_DECIBELS],
          max:                  [-100, 0, -30,  "maximal decibel value for scaling the FFT analysis data, where 0 dB is the loudest possible sound, -10 dB is a 10th of that, etc.", SHOW_AS_DECIBELS],
          curve:                [0, 10, 1, "adjusts decibel significance curve"]
        },
        angle:                  [-360, 360, 0, "Angle of frequency zoom impact", SHOW_AS_DEGREES],
      },
      waveform: {
        impact:                 [0, 1, 0],
        mirror:                 ["boolean", true],
        angle:                  [-360, 360, 0, "Angle of waveform zoom impact", SHOW_AS_DEGREES],
      }
    },
    shift: {
      rate:                     [ [-1, -1], [1, 1], [0, 0] ],
      frequency: {
        horizontal: {
          impact:               [-1, 1, 0],
          range: {
            min:                [0, 1, 0, "in hertz", SHOW_AS_FREQUENCY],
            max:                [0, 1, 1, "in hertz", SHOW_AS_FREQUENCY],
            logScale:           ["boolean", false],
          },
          loudness: {
            min:                [-100, 0, -100, "minimum decibel value for scaling the FFT analysis data, where 0 dB is the loudest possible sound, -10 dB is a 10th of that, etc.", SHOW_AS_DECIBELS],
            max:                [-100, 0, -30,  "maximal decibel value for scaling the FFT analysis data, where 0 dB is the loudest possible sound, -10 dB is a 10th of that, etc.", SHOW_AS_DECIBELS],
            curve:              [0, 10, 1, "adjusts decibel significance curve"]
          }
        },
        vertical: {
          impact:               [-1, 1, 0],
          range: {
            min:                [0, 1, 0, "in hertz", SHOW_AS_FREQUENCY],
            max:                [0, 1, 1, "in hertz", SHOW_AS_FREQUENCY],
            logScale:           ["boolean", false],
          },
          loudness: {
            min:                [-100, 0, -100, "minimum decibel value for scaling the FFT analysis data, where 0 dB is the loudest possible sound, -10 dB is a 10th of that, etc.", SHOW_AS_DECIBELS],
            max:                [-100, 0, -30,  "maximal decibel value for scaling the FFT analysis data, where 0 dB is the loudest possible sound, -10 dB is a 10th of that, etc.", SHOW_AS_DECIBELS],
            curve:              [0, 10, 1, "adjusts decibel significance curve"]
          }
        }
      },
      waveform: {
        horizontal: {
          impact:               [0, 1, 0],
        },
        vertical: {
          impact:               [0, 1, 0],
        }
      }
    },
    noise: {
      impact:                   [-2, 2, 0],
      scale:                    [0, 25, 1],
      phase:                    [-10, 10, 0],
      shift:                    [ [-10, -10], [10, 10], [0, 0] ],
      speed: {
        phase:                  [-10, 10, .2],
        shift:                  [ [-10, -10], [10, 10], [0, 0] ],
      }
    }
  },
  draw: {
    noise: {
      mix:                      ["boolean", false, "mix noise colors instead of adding them in RGB space"],
      mixFactor:                [0, 1, 1, "the amount of noise colors to be mixed"],
      intensity:                [0, 1, 0],
      color:                    ["color", [1, 1, 1] ],
      scale:                    [0, 25, 1],
      phase:                    [-10, 10, 0],
      shift:                    [ [-10, -10], [10, 10], [0, 0] ],
      slice: {
        start:                  [0, 1, .0],
        end:                    [0, 1, .5],
        frequency: {
          apply:                ["boolean", false, "apply frequency spectrum to slice"],
          range: {
            min:                [0, 1, 0, "in hertz", SHOW_AS_FREQUENCY],
            max:                [0, 1, 1, "in hertz", SHOW_AS_FREQUENCY],
            logScale:           ["boolean", false]
          },
          loudness: {
            min:                [-100, 0, -100, "minimum decibel value for scaling the FFT analysis data, where 0 dB is the loudest possible sound, -10 dB is a 10th of that, etc.", SHOW_AS_DECIBELS],
            max:                [-100, 0, -30,  "maximal decibel value for scaling the FFT analysis data, where 0 dB is the loudest possible sound, -10 dB is a 10th of that, etc.", SHOW_AS_DECIBELS],
            curve:              [0, 10, 1, "adjusts decibel significance curve"]
          },
          shift:                [0, 1, 0, "Frequency spectrum phase shift"]
        }
      },
      edge: {
        inner: {
          start:                [0, 1, 0],
          end:                  [0, 1, 0.0001]
        },
        outer: {
          start:                [0, 1, 0.4999],
          end:                  [0, 1, .5]
        }
      },
      spectrum: {
        intensity:              [0, 1, 0],
        color:                  ["color", [1, 1, 1] ]
      },
      palette: {
        intensity:              [0, 1, 0],
        a:                      [ [0, 0, 0], [1, 1, 1], [.5, .5, .5] ],
        b:                      [ [0, 0, 0], [1, 1, 1], [.5, .5, .5] ],
        c:                      [ [0, 0, 0], [1, 1, 1], [1, 1, 1] ],
        d:                      [ [0, 0, 0], [1, 1, 1], [0.00, 0.33, 0.67] ],
      },
      speed: {
        phase:                  [-10, 10, .2],
        shift:                  [ [-10, -10], [10, 10], [0, 0] ]
      }
    },
    shape: {
      mix:                      ["boolean", false, "mix noise colors instead of adding them in RGB space"],
      mixFactor:                [0, 1, 1, "the amount of shape colors to be mixed"],
      intensity:                [0, 1, 1],
      color:                    ["color", [1, 1, 1] ],
      center:                   [ [-10, -10], [10, 10], [0,0] ],
      vertices:                 ["integer", 1, 20, 3, "the number of vertices - 1 stands for a circle"],
      size:                     [0, 3, .618033],
      angle:                    [-360, 360, 0, "Shape angle", SHOW_AS_DEGREES],
      slice: {
        start:                  [0, 1, .97],
        end:                    [0, 1, 1],
        frequency: {
          apply:                ["boolean", false, "apply frequency spectrum to slice"],
          range: {
            min:                [0, 1, 0, "in hertz", SHOW_AS_FREQUENCY],
            max:                [0, 1, 1, "in hertz", SHOW_AS_FREQUENCY],
            logScale:           ["boolean", false]
          },
          loudness: {
            min:                [-100, 0, -100, "minimum decibel value for scaling the FFT analysis data, where 0 dB is the loudest possible sound, -10 dB is a 10th of that, etc.", SHOW_AS_DECIBELS],
            max:                [-100, 0, -30,  "maximal decibel value for scaling the FFT analysis data, where 0 dB is the loudest possible sound, -10 dB is a 10th of that, etc.", SHOW_AS_DECIBELS],
            curve:              [0, 10, 1, "adjusts decibel significance curve"]
          },
          shift:                [0, 1, 0, "Frequency spectrum phase shift"]
        }
      },
      edge: {
        inner: {
          start:                [0, 1, .96],
          end:                  [0, 1, .97]
        },
        outer: {
          start:                [0, 1, .99],
          end:                  [0, 1, 1]
        }
      },
      spectrum: {
        intensity:              [0, 1, 0],
        color:                  ["color", [1, 1, 1] ]
      },
      palette: {
        intensity:              [0, 1, 0],
        a:                      [ [0, 0, 0], [1, 1, 1], [.5, .5, .5] ],
        b:                      [ [0, 0, 0], [1, 1, 1], [.5, .5, .5] ],
        c:                      [ [0, 0, 0], [1, 1, 1], [1, 1, 1] ],
        d:                      [ [0, 0, 0], [1, 1, 1], [0.00, 0.33, 0.67] ],
      },
      frequency: {
        impact:                 [-1, 10, 0],
        range: {
          min:                  [0, 1, 0, "in hertz", SHOW_AS_FREQUENCY],
          max:                  [0, 1, 1, "in hertz", SHOW_AS_FREQUENCY],
          logScale:             ["boolean", false],
        },
        loudness: {
          min:                  [-100, 0, -100, "minimum decibel value for scaling the FFT analysis data, where 0 dB is the loudest possible sound, -10 dB is a 10th of that, etc.", SHOW_AS_DECIBELS],
          max:                  [-100, 0, -30,  "maximal decibel value for scaling the FFT analysis data, where 0 dB is the loudest possible sound, -10 dB is a 10th of that, etc.", SHOW_AS_DECIBELS],
          curve:                [0, 10, 1, "adjusts decibel significance curve"]
        },
        angle:                  [-360, 360, 0, "the angle of frequency zoom impact", SHOW_AS_DEGREES],
      },
      /*
      frequency: {
        impact:                 [-1, 1, 0],
        range: {
          min:                  [0, 1, 0, "in hertz", SHOW_AS_FREQUENCY],
          max:                  [0, 1, 1, "in hertz", SHOW_AS_FREQUENCY]
        }
      },
      */
      speed: {
        rotation:               [-3, 3, .1, "rotations per second"]
      }
    }
  },
  ripple: {
    impact:                     [0, 1, 0, "the amount of refraction the ripple will produce in the highest point"],
    center:                     [ [-10, -10], [10, 10], [0, 0], "the point from which ripples are being propagated" ],
    scale:                      [0, 50, 5, "number of ripples visible - 1 = one full ripple period since the center to the edge of the shortest screen coordinate"],
    phase:                      [0, 1, 0, "phase of the ripple, see also visualizer.ripple.speed.phase - to synchronize with beat use: visualizer.ripple.phase = music.beat.signal(1)"],
    speed: {
      phase:                    [-10, 10, 1, "ripple phase shifts per second"]
    }
  },
  glass: {
    refraction:                 [0, 1, 0, "the scale of refraction the glass will produce"],
    color: {
      impact:                   [0, 1, 0, "the amount of own color the glass will overlay"],
      base:                     ["color", [1, 1, 1], "the base color to mix"],
      tint:                     ["color", [1, 1, 1], "the tint over background color sampled after applying refraction"],
    },
    center:                     [ [-10, -10], [10, 10], [0, 0] ],
    vertices:                   ["integer", 1, 20, 5, "the number of vertices - 1 stands for a circle"],
    width:                      [0, 1, .5],
    edge: {
      width:                    [0, 1, .1],
      thickness:                [-2, 2, .1],
      smoothing:                [0, 1, .05]
    },
    angle:                      [-360, 360, 0, "Glass angle", SHOW_AS_DEGREES],
    phase:                      [0, 1, 0, "phase of the ripple, see also visualizer.glass.speed.phase - to synchronize with beat use: visualizer.glass.phase = music.beat.signal(1)"],
    fade:                       [0, 2, 1],
    perspective:                ["boolean", false],
    scale:                      [0, 10, 1],
    speed: {
      phase:                    [-10, 10, 1, "glass segment shift per second"],
      rotation:                 [-3, 3, .1, "rotations per second"]
    }
  }
};
        // TODO where is it used?
function getSource(object) {
  var output = [], temp;
  for (const i in object) {
    if (object.hasOwnProperty(i)) {
      temp = i + ":";
      switch (typeof object[i]) {
        case "object" :
          temp += getSource(object[i]);
          break;
        case "string" :
          temp += "\"" + object[i] + "\"";    // add in some code to escape quotes
          break;
        default :
          temp += object[i];
      }
      output.push(temp);
    }
  }
  return "{" + output.join() + "}";
};

function evaluateMapping(mapping) {
  eval(mapping); // if something is wrong, it will fail fast while trying to set up values
  // setting some values too early will be immediately overridden on next frame by the current visualizer mapping
  // as it happens only during visual design, I assume that some rare glitches are acceptable
  visualizer.mapping = eval("(() => {" + mapping + "})");
}

function propagateExperience(manifest) {
  experience.title = manifest.title;
  experience.description = manifest.description;
  propagateControls(manifest.controls, defaultControls, controls);
  evaluateMapping(manifest.mapping);
}

// we can assume that destination is always fully cloned from defaults
function propagateControls(source, defaults, destination) {
  for (const name in destination) {
    const value = (typeof source[name] === "undefined") ? defaults[name] : source[name];
    if (value instanceof Array) {
      destination[name] = Array.from(value);
    } else if ((typeof value  === "number") || (typeof value  === "boolean")) {
      destination[name] = value;
    } else { // object
      propagateControls(
        source[name] || {}, // in case when experience doesn't have some new group
        defaults[name],
        destination[name]
      );
    }
  }
}

function extractDefault(metadata, path) {
  if ((typeof metadata[0] === "number") || (metadata[0] instanceof Array)) {
    return metadata[2];
  } else if (typeof metadata[0] === "string") {
    if (metadata[0] == "integer") {
      return metadata[3];
    } else {
      return metadata[1];
    }
  } else {
    console.error("Unsupported metadata type on control: " + name);
  }
}

function extractDefaults(metadata, path) {
  const defaults = {};
  for (const name in metadata) {
    const child = metadata[name];
    const childPath = path + "." + name;
    defaults[name] = (child instanceof Array)
      ? extractDefault(child, childPath) : extractDefaults(child, childPath);
    if (typeof defaults[name] === "undefined") {
      console.error("undefined default: " + childPath);
    }
  }
  return defaults;
}

function extractVisualizerStructure(metadata) {
  const visualizerNode = {};
  for (const name in metadata) {
    const child = metadata[name];
    if (
      (typeof child === "object")
        && (child !== null)
        && !Array.isArray(child)
    ) {
      visualizerNode[name] = extractVisualizerStructure(metadata[name]);
    }
  }
  return visualizerNode;
}

// we also need to call this factory again im mapping.js
const getDefaultControls = () => extractDefaults(controlsMetadata, "controls");
const getDefaultVisualizerStructure = () => extractVisualizerStructure(controlsMetadata);
const defaultControls = getDefaultControls();

const newDefaultExperience = () => ({
  title: "Default",
  description: "A default experience derived from the default values, good starting point for customization (including this description)",
  controls: getDefaultControls(),
  mapping: "visualizer.draw.shape.size = controls.draw.shape.size + cos(music.beat.period(1)) * .1;\n"
});

const exportVisualizer = () => JSON.stringify(
  {
    title: experience.title,
    description: experience.description,
    controls: controls,
    mapping: getFunctionBody(visualizer.mapping)
  },
  null,
  2
);

let seconds = 0;
let audioDataRenderer;

        // structures defining state which determines visualizer appearance and motion
// for the "music" namespace check visualizer-api.js

// metadata of currently displayed experience
const experience = {
  title: "Default",
  description: "Default"
}

// all the visualizer controls with presets obtained from default metadata
const controls = getDefaultControls();

// tree of visual parameters, usually passed to shaders as uniforms, obtained from default metadata
const visualizer = getDefaultVisualizerStructure();

// physical properties of the display screen (JS screen is already in the global namespace)
const display = {
  width: 0,
  height: 0,
  ratio: 1
}

// progress keeps coefficients automatically updated each frame with intervals based on specified speed
const progress = {
  feedback: {
    noise: {
      phase: 0,
      shift: [0, 0]
    }
  },
  draw: {
    noise: {
      phase: 0,
      shift: [0, 0]
    },
    shape: {
      rotation: 0
    }
  },
  ripple: {
    phase: 0
  },
  glass: {
    phase: 0,
    rotation: 0
  }
}
        // see state.js to check what progress means
function mapProgress(timeDelta) {

  progress.feedback.noise.phase += controls.feedback.noise.speed.phase * timeDelta;
  progress.feedback.noise.shift = addVectors(
    progress.feedback.noise.shift,
    multiplyVectors(
      controls.feedback.noise.speed.shift,
      toVector2(timeDelta)
    )
  );

  progress.draw.shape.rotation += controls.draw.shape.speed.rotation * timeDelta;

  progress.draw.noise.phase += controls.draw.noise.speed.phase * timeDelta;
  progress.draw.noise.shift = addVectors(
    progress.draw.noise.shift,
    multiplyVectors(
      controls.draw.noise.speed.shift,
      toVector2(timeDelta)
    )
  );

  progress.ripple.phase += controls.ripple.speed.phase * timeDelta;

  progress.glass.phase += controls.glass.speed.phase * timeDelta;
  progress.glass.rotation += controls.glass.speed.rotation * timeDelta;

}

function mapControlsToVisualizer() {
  visualizer.analyser.frequency.samples = controls.analyser.frequency.samples;
  visualizer.analyser.frequency.smoothing = controls.analyser.frequency.smoothing;
  visualizer.analyser.frequency.logScale = controls.analyser.frequency.logScale;
  visualizer.analyser.waveform.samples = controls.analyser.waveform.samples;

  visualizer.color.gammaCorrection = controls.color.gammaCorrection;
  visualizer.color.invert = controls.color.invert;
  visualizer.feedback.fade.color = multiplyVectors(controls.feedback.fade.color, toVector3(controls.feedback.fade.rate));
  visualizer.feedback.rotation.center = controls.feedback.rotation.center;
  visualizer.feedback.rotation.angle = toRadians(controls.feedback.rotation.angle);
  visualizer.feedback.zoom.center = controls.feedback.zoom.center;
  visualizer.feedback.zoom.scale = controls.feedback.zoom.scale;
  visualizer.feedback.zoom.frequency.impact = controls.feedback.zoom.frequency.impact;
  visualizer.feedback.zoom.frequency.range.min = controls.feedback.zoom.frequency.range.min;
  visualizer.feedback.zoom.frequency.range.max = controls.feedback.zoom.frequency.range.max;
  visualizer.feedback.zoom.frequency.range.logScale = controls.feedback.zoom.frequency.range.logScale;
  visualizer.feedback.zoom.frequency.loudness.min = controls.feedback.zoom.frequency.loudness.min;
  visualizer.feedback.zoom.frequency.loudness.max = controls.feedback.zoom.frequency.loudness.max;
  visualizer.feedback.zoom.frequency.loudness.curve = controls.feedback.zoom.frequency.loudness.curve;
  visualizer.feedback.zoom.frequency.angle = toRadians(controls.feedback.zoom.frequency.angle);
  visualizer.feedback.zoom.waveform.impact = controls.feedback.zoom.waveform.impact;
  visualizer.feedback.zoom.waveform.mirror = controls.feedback.zoom.waveform.mirror;
  visualizer.feedback.zoom.waveform.angle = toRadians(controls.feedback.zoom.waveform.angle);
  visualizer.feedback.shift.rate = controls.feedback.shift.rate;
  visualizer.feedback.shift.frequency.horizontal.impact = controls.feedback.shift.frequency.horizontal.impact;
  visualizer.feedback.shift.frequency.horizontal.range.min = controls.feedback.shift.frequency.horizontal.range.min;
  visualizer.feedback.shift.frequency.horizontal.range.max = controls.feedback.shift.frequency.horizontal.range.max;
  visualizer.feedback.shift.frequency.horizontal.range.logScale = controls.feedback.shift.frequency.horizontal.range.logScale;
  visualizer.feedback.shift.frequency.horizontal.loudness.min = controls.feedback.shift.frequency.horizontal.loudness.min;
  visualizer.feedback.shift.frequency.horizontal.loudness.max = controls.feedback.shift.frequency.horizontal.loudness.max;
  visualizer.feedback.shift.frequency.horizontal.loudness.curve = controls.feedback.shift.frequency.horizontal.loudness.curve;
  visualizer.feedback.shift.frequency.vertical.impact = controls.feedback.shift.frequency.vertical.impact;
  visualizer.feedback.shift.frequency.vertical.range.min = controls.feedback.shift.frequency.vertical.range.min;
  visualizer.feedback.shift.frequency.vertical.range.max = controls.feedback.shift.frequency.vertical.range.max;
  visualizer.feedback.shift.frequency.vertical.range.logScale = controls.feedback.shift.frequency.vertical.range.logScale;
  visualizer.feedback.shift.frequency.vertical.loudness.min = controls.feedback.shift.frequency.vertical.loudness.min;
  visualizer.feedback.shift.frequency.vertical.loudness.max = controls.feedback.shift.frequency.vertical.loudness.max;
  visualizer.feedback.shift.frequency.vertical.loudness.curve = controls.feedback.shift.frequency.vertical.loudness.curve;
  visualizer.feedback.shift.waveform.horizontal.impact = controls.feedback.shift.waveform.horizontal.impact;
  visualizer.feedback.shift.waveform.vertical.impact = controls.feedback.shift.waveform.vertical.impact;
  visualizer.feedback.noise.impact = controls.feedback.noise.impact;
  visualizer.feedback.noise.scale = controls.feedback.noise.scale;
  visualizer.feedback.noise.phase = controls.feedback.noise.phase + progress.feedback.noise.phase;
  visualizer.feedback.noise.shift = addVectors(controls.feedback.noise.shift, progress.feedback.noise.shift);

  visualizer.draw.noise.mix = controls.draw.noise.mix;
  visualizer.draw.noise.mixFactor = controls.draw.noise.mixFactor;
  visualizer.draw.noise.color = multiplyVectors(controls.draw.noise.color, toVector3(controls.draw.noise.intensity));
  visualizer.draw.noise.scale = controls.draw.noise.scale;
  visualizer.draw.noise.slice.start = controls.draw.noise.slice.start;
  visualizer.draw.noise.slice.end = controls.draw.noise.slice.end;
  visualizer.draw.noise.edge.inner.start = controls.draw.noise.edge.inner.start;
  visualizer.draw.noise.edge.inner.end = controls.draw.noise.edge.inner.end;
  visualizer.draw.noise.edge.outer.start = controls.draw.noise.edge.outer.start;
  visualizer.draw.noise.edge.outer.end = controls.draw.noise.edge.outer.end;
  visualizer.draw.noise.spectrum.color = multiplyVectors(controls.draw.noise.spectrum.color, toVector3(controls.draw.noise.spectrum.intensity));
  visualizer.draw.noise.phase = controls.draw.noise.phase + progress.draw.noise.phase;
  visualizer.draw.noise.shift = addVectors(controls.draw.noise.shift, progress.draw.noise.shift);
  visualizer.draw.noise.slice.frequency.range.min = controls.draw.noise.slice.frequency.range.min;
  visualizer.draw.noise.slice.frequency.range.max = controls.draw.noise.slice.frequency.range.max;
  visualizer.draw.noise.slice.frequency.range.logScale = controls.draw.noise.slice.frequency.range.logScale;
  visualizer.draw.noise.slice.frequency.loudness.min = controls.draw.noise.slice.frequency.loudness.min;
  visualizer.draw.noise.slice.frequency.loudness.max = controls.draw.noise.slice.frequency.loudness.max;
  visualizer.draw.noise.slice.frequency.loudness.curve = controls.draw.noise.slice.frequency.loudness.curve;
  visualizer.draw.noise.slice.frequency.shift = controls.draw.noise.slice.frequency.shift;
  visualizer.draw.noise.slice.frequency.apply = controls.draw.noise.slice.frequency.apply;
  visualizer.draw.noise.palette.intensity = controls.draw.noise.palette.intensity;
  visualizer.draw.noise.palette.a = controls.draw.noise.palette.a;
  visualizer.draw.noise.palette.b = controls.draw.noise.palette.b;
  visualizer.draw.noise.palette.c = controls.draw.noise.palette.c;
  visualizer.draw.noise.palette.d = controls.draw.noise.palette.d;

  visualizer.draw.shape.mix = controls.draw.shape.mix;
  visualizer.draw.shape.mixFactor = controls.draw.shape.mixFactor;
  visualizer.draw.shape.intensity = controls.draw.shape.intensity;
  visualizer.draw.shape.color = multiplyVectors(controls.draw.shape.color, toVector3(controls.draw.shape.intensity));
  visualizer.draw.shape.center = controls.draw.shape.center;
  visualizer.draw.shape.vertices = controls.draw.shape.vertices;
  visualizer.draw.shape.size = controls.draw.shape.size;
  visualizer.draw.shape.angle = toRadians(controls.draw.shape.angle + progress.draw.shape.rotation * 360);
  visualizer.draw.shape.slice.start = controls.draw.shape.slice.start;
  visualizer.draw.shape.slice.end = controls.draw.shape.slice.end;
  visualizer.draw.shape.edge.inner.start = controls.draw.shape.edge.inner.start;
  visualizer.draw.shape.edge.inner.end = controls.draw.shape.edge.inner.end;
  visualizer.draw.shape.edge.outer.start = controls.draw.shape.edge.outer.start;
  visualizer.draw.shape.edge.outer.end = controls.draw.shape.edge.outer.end;
  visualizer.draw.shape.spectrum.color = multiplyVectors(controls.draw.shape.spectrum.color, toVector3(controls.draw.shape.spectrum.intensity));
  visualizer.draw.shape.frequency.impact = controls.draw.shape.frequency.impact;
  visualizer.draw.shape.frequency.range.min = controls.draw.shape.frequency.range.min;
  visualizer.draw.shape.frequency.range.max = controls.draw.shape.frequency.range.max;
  visualizer.draw.shape.frequency.range.logScale = controls.draw.shape.frequency.range.logScale;
  visualizer.draw.shape.frequency.loudness.min = controls.draw.shape.frequency.loudness.min;
  visualizer.draw.shape.frequency.loudness.max = controls.draw.shape.frequency.loudness.max;
  visualizer.draw.shape.frequency.loudness.curve = controls.draw.shape.frequency.loudness.curve;
  visualizer.draw.shape.frequency.angle = toRadians(controls.draw.shape.frequency.angle);
  visualizer.draw.shape.slice.frequency.range.min = controls.draw.shape.slice.frequency.range.min;
  visualizer.draw.shape.slice.frequency.range.max = controls.draw.shape.slice.frequency.range.max;
  visualizer.draw.shape.slice.frequency.range.logScale = controls.draw.shape.slice.frequency.range.logScale;
  visualizer.draw.shape.slice.frequency.loudness.min = controls.draw.shape.slice.frequency.loudness.min;
  visualizer.draw.shape.slice.frequency.loudness.max = controls.draw.shape.slice.frequency.loudness.max;
  visualizer.draw.shape.slice.frequency.loudness.curve = controls.draw.shape.slice.frequency.loudness.curve;
  visualizer.draw.shape.slice.frequency.shift = controls.draw.shape.slice.frequency.shift;
  visualizer.draw.shape.slice.frequency.apply = controls.draw.shape.slice.frequency.apply;
  visualizer.draw.shape.palette.intensity = controls.draw.shape.palette.intensity;
  visualizer.draw.shape.palette.a = controls.draw.shape.palette.a;
  visualizer.draw.shape.palette.b = controls.draw.shape.palette.b;
  visualizer.draw.shape.palette.c = controls.draw.shape.palette.c;
  visualizer.draw.shape.palette.d = controls.draw.shape.palette.d;

  visualizer.ripple.center = controls.ripple.center;
  visualizer.ripple.impact = controls.ripple.impact;
  visualizer.ripple.scale = controls.ripple.scale;
  visualizer.ripple.phase = controls.ripple.phase + progress.ripple.phase;

  visualizer.glass.refraction = controls.glass.refraction;
  visualizer.glass.color.impact = controls.glass.color.impact;
  visualizer.glass.color.base = controls.glass.color.base;
  visualizer.glass.color.tint = controls.glass.color.tint;
  visualizer.glass.center = controls.glass.center;
  visualizer.glass.vertices = controls.glass.vertices;
  visualizer.glass.width = controls.glass.width;
  visualizer.glass.edge.width = controls.glass.edge.width;
  visualizer.glass.edge.thickness = controls.glass.edge.thickness;
  visualizer.glass.edge.smoothing = controls.glass.edge.smoothing;
  visualizer.glass.angle = toRadians(controls.glass.angle + progress.glass.rotation * 360);
  visualizer.glass.phase = controls.glass.phase + progress.glass.phase;
  visualizer.glass.fade = controls.glass.fade;
  visualizer.glass.perspective = controls.glass.perspective;
  visualizer.glass.scale = controls.glass.scale;
}
        class AudioAnalyser {

  constructor(audioDataRenderer) {
    this.audioDataRenderer = audioDataRenderer;
  }

  // this should be a private method, but does not work on Safari :(
  newAnalyser(audioContext) {
    const analyser = audioContext.createAnalyser();
    // we are changing the default decibel range, after switching to Float-based analyser methods
    // instead of Byte-based, this setting should have no influence anyway. Decibel renges are set
    // per specific parameter-influence now
    analyser.minDecibels = -100;
    analyser.maxDecibels = 0;
    return analyser;
  }

  // TODO mono/stereo rewiring
  start(audioContext, source) {
    this.source = source;
    this.splitter = audioContext.createChannelSplitter();
    source.connect(this.splitter);

    this.leftAnalyser = this.newAnalyser(audioContext);
    this.rightAnalyser = this.newAnalyser(audioContext);
    this.timeDomainAnalyser = this.newAnalyser(audioContext);
    this.splitter.connect(this.leftAnalyser, 0, 0);
    this.splitter.connect(this.rightAnalyser, 1, 0);
    source.connect(this.timeDomainAnalyser);
  }

  stop() {
    this.source.disconnect(this.timeDomainAnalyser);
    this.splitter.disconnect();
    this.source.disconnect(this.splitter);
    this.source = null;
  }

  analyse(frequencySamples, waveformSamples, smoothing) {
    if (!this.source) {
      return;
    }
    this.analyseChannel(
      frequencySamples,
      smoothing,
      this.leftAnalyser,
      this.audioDataRenderer.leftFrequencies
    )
    this.analyseChannel(
      frequencySamples,
      smoothing,
      this.rightAnalyser,
      this.audioDataRenderer.rightFrequencies
    )
    this.analyseWaveform(waveformSamples);
  }

  // TODO extract common code

  analyseChannel(samples, smoothing, analyser, renderer) {
    analyser.smoothingTimeConstant = smoothing;
    if ((samples * 2) !== analyser.fftSize) {
      analyser.fftSize = (samples * 2);
      renderer.resize(samples);
    }
    analyser.getFloatFrequencyData(renderer.data);
  }

  analyseWaveform(
    samples
  ) {
    const analyser = this.timeDomainAnalyser;
    const renderer = this.audioDataRenderer.waveform;
    if (samples !== analyser.fftSize) {
      analyser.fftSize = samples;
      renderer.resize(samples);
    }
    analyser.getFloatTimeDomainData(renderer.data);
  }

}
        // API being called indirectly by AiMi apps (see aimi-interface-app.js/aimi-interface-studio.js)
// the main responsibility of this layer is to calculate the state of "music" namespace either when
// the messages are arriving or just before the frame is rendered.
//
// see state.js
const visualizerApi = {

  connectAudio: (wsurl) => {
    aimiAudioStream.start(wsurl);
  },

  // this one seems to be not used anymore
  startVisualization: () => {
  },

  // this one is called though
  stopVisualization: () => {
    resetMusicState();
  },

  enableLowPower: () => {
  },

  disableLowPower: () => {
  },

  // FIXME this function should be removed when all the manifests are managed externally, see setCurrentVisualizerManifest, probably startVisualization() and stopVisualization() should be responsible for resetMusicState() - pause / stop, otherwise visualizer is counting too much beats
  startExperience: (manifest) => {
    resetMusicState();
    propagateExperience(manifest);
  },

  handleLoopMessage: (bpm) => {
    music.bpm = bpm;
  },

  handleSectionMessage: (sectionType, sectionStartBeat, sectionLength) => {
    if (music.beat >= sectionStartBeat) {
      music.section.current.type = sectionType;
      music.section.current.length = sectionLength;
      music.section.current.startBeat = sectionStartBeat;
      music.section.next.startBeat = sectionStartBeat + sectionLength;
    } else {
      music.section.next.type = sectionType;
      music.section.next.length = sectionLength;
      music.section.next.startBeat = sectionStartBeat;
    }
  },

  handleSubsectionMessage: (subsectionType, subsectionStartBeat, subsectionLength) => {
    // -- Not sure if we really care about subsections -- //
    // if (music.beat >= subsectionStartBeat) {
    //   music.subsection.current.type = subsectionType;
    //   music.subsection.current.length = subsectionLength;
    //   music.subsection.current.startBeat = subsectionStartBeat;
    //   music.subsection.next.startBeat = subsectionStartBeat + subsectionLength;
    // } else {
    //   music.subsection.next.type = subsectionType;
    //   music.subsection.next.length = subsectionLength;
    //   music.subsection.next.startBeat = subsectionStartBeat;
    // }
  },

  handlePerformanceBeatMessage: (beatNumber) => {
    music.beat.last.number = beatNumber;
    music.beat.last.time = performance.now() / 1000;
    if (beatNumber >= music.section.next.startBeat) {
      music.section.current.type = music.section.next.type;
      music.section.current.length = music.section.next.length;
      music.section.current.startBeat = music.section.next.startBeat;
      music.section.next.startBeat = music.section.current.startBeat + music.section.current.length;
    }
    music.beat.number = beatNumber;
  },

  handleNowPlayingMessage: (nowPlaying) => {
    music.group.beats.id = nowPlaying.beats;
    music.group.bass.id = nowPlaying.bass;
    music.group.harmony.id = nowPlaying.harmony;
    music.group.tops.id = nowPlaying.tops;
    music.group.melody.id = nowPlaying.melody;
    music.group.fx.id = nowPlaying.fx;
    music.group.fx_b.id = nowPlaying.fx_b;
    // ignore the 'beat' argument for the moment - assume it represents 'now'
  },

  getCurrentVisualizerManifest: exportVisualizer,

  setCurrentVisualizerManifest: (manifestJSON) => {
    const manifest = JSON.parse(manifestJSON);
    propagateExperience(manifest);
  },

  setMapping: (mapping) => {
    evaluateMapping(mapping);
  }

}

// state resolved for the music being currently played
const music = {
  beat: {
    number: -4, // current numeric value of the beat as constantly updated floating point value
    signal: (span) => (music.beat.number % span) / span,
    period: (span) => (music.beat.number % span) / span * TWO_PI,
    last: {
      number: -4,    // integer number
      time: 0        // beat occurrence time in seconds
    }
  },
  bpm: 0,         // @Toby, should it be bpm or tempo?
  section: {
    current: {
      type: "",
      length: 0,
      startBeat: 0,
      relativeBeat: 0,
      progress: 0
    },
    next: {
      type: "",
      length: 0,
      startBeat: 0,
      relativeBeat: 0
    }
  },
  group: {
    beats: { id: 0 },
    bass: { id: 0 },
    harmony: { id: 0 },
    pads: { id: 0 },
    tops: { id: 0 },
    melody: { id: 0 },
    fx: { id: 0 },
    fx_b: { id: 0 }
  }
}

// this function is called before each rendered frame to establish values in music namespace
function calculateMusicState() {
  const deltaBeatTime = seconds - music.beat.last.time;
  music.beat.number = music.beat.last.number + (deltaBeatTime * music.bpm / 60);
  music.section.current.relativeBeat = (music.beat.number - music.section.current.startBeat) % music.section.current.length;
  music.section.next.relativeBeat = (music.beat.number - music.section.next.startBeat);
  music.section.current.progress = (music.beat.number - music.section.current.startBeat) / music.section.current.length;
}

function resetMusicState() {
  music.beat.number = -4;
  music.beat.last.number = -4;
  music.beat.last.time = 0;
  music.bpm = 0;
  music.section.current.type = "";
  music.section.current.length = 0;
  music.section.current.startBeat = 0;
  music.section.next.type = "";
  music.section.next.length = 0;
  music.section.next.startBeat = 0;
  music.section.current.progress = 0;
}

        when(document, "DOMContentLoaded", () => {
          const ANALYSER_TEXTURE_WIDTH = 2048;
const ANALYSER_TEXTURE_ROWS = 9;
const ANALYSER_TEXTURE_RESOLUTION = [ANALYSER_TEXTURE_WIDTH, ANALYSER_TEXTURE_ROWS];
const NOISE_TEXTURE_DIVIDER = 8; // noise texture is of a lower resolution than the whole image

propagateExperience(newDefaultExperience());

shaderWebBackground.shade((ctx) => {

  let time = 0;
  let previousTime = 0;
  let minDimension;
  let screenRatioHalf;
  let analyser;
  let drawNoiseApply;

  const isDrawNoiseApply = () => !(
    isZeroVector(visualizer.draw.noise.color)
    && isZeroVector(visualizer.draw.noise.spectrum.color)
    && (visualizer.draw.noise.palette.intensity === 0)
  ) || visualizer.draw.noise.mix;

  const isDrawShapeApply = () => !(
      isZeroVector(visualizer.draw.shape.color)
      && isZeroVector(visualizer.draw.shape.spectrum.color)
      && (visualizer.draw.shape.palette.intensity === 0)
  ) || visualizer.draw.shape.mix;

  return {
    canvas: getCanvas(), // different mechanism for in-app visualizer and the tool
    onInit: () => {
      audioDataRenderer = new AudioDataRenderer(ctx.gl);
      analyser = new AudioAnalyser(audioDataRenderer);
      initialize(analyser, audioDataRenderer, visualizerApi);
    },
    onResize: (width, height) => {
      minDimension = Math.min(width, height);
      const screenRatio = (width >= height)
        ? [(height / width), 1]
        : [1, (width / height)];
      screenRatioHalf = multiplyVectors(screenRatio, [.5, .5]);
      display.width = width;
      display.height = height;
      display.ratio = width / height;
    },
    onBeforeFrame: () => {
      seconds = performance.now() / 1000;
      const deltaTime = seconds - previousTime;
      previousTime = seconds;
      calculateMusicState();
      mapProgress(deltaTime);
      mapControlsToVisualizer();
      visualizer.mapping();
      analyser.analyse(
        pow(2, visualizer.analyser.frequency.samples),
        pow(2, visualizer.analyser.waveform.samples),
        visualizer.analyser.frequency.smoothing
      );
      audioDataRenderer.render();
      drawNoiseApply = isDrawNoiseApply();
      onEachFrame();
    },
    shaders: {
      audio: {
        texture: (gl, ctx) => {
          const width = ANALYSER_TEXTURE_WIDTH;
          const height = ANALYSER_TEXTURE_ROWS;
          ctx.initHalfFloatRGBATexture(width, height);
          // the texture will be already of a quite high resolution, so linear filtering is not needed and NEAREST makes it faster to read
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          return {
            width: width,
            height: height
          }
        },
        uniforms: {
          iResolution:                                    () => ANALYSER_TEXTURE_RESOLUTION,
          iTextureLeftFrequencies:                        () => audioDataRenderer.leftFrequencies.getTexture(),
          iTextureRightFrequencies:                       () => audioDataRenderer.rightFrequencies.getTexture(),
          iTextureWaveform:                               () => audioDataRenderer.waveform.getTexture(),
          iFeedbackZoomFrequencyImpact:                   () => visualizer.feedback.zoom.frequency.impact,
          iFeedbackZoomFrequencyRangeMin:                 () => visualizer.feedback.zoom.frequency.range.min,
          iFeedbackZoomFrequencyRangeMax:                 () => visualizer.feedback.zoom.frequency.range.max,
          iFeedbackZoomFrequencyRangeLogScale:            () => visualizer.feedback.zoom.frequency.range.logScale,
          iFeedbackZoomFrequencyLoudnessMin:              () => visualizer.feedback.zoom.frequency.loudness.min,
          iFeedbackZoomFrequencyLoudnessMax:              () => visualizer.feedback.zoom.frequency.loudness.max,
          iFeedbackZoomFrequencyLoudnessCurve:            () => visualizer.feedback.zoom.frequency.loudness.curve,
          iFeedbackZoomFrequencyPhase:                    () => visualizer.feedback.zoom.frequency.angle / TWO_PI,
          iFeedbackZoomWaveformImpact:                    () => visualizer.feedback.zoom.waveform.impact,
          iFeedbackZoomWaveformMirror:                    () => visualizer.feedback.zoom.waveform.mirror,
          iFeedbackZoomWaveformPhase:                     () => visualizer.feedback.zoom.waveform.angle / TWO_PI,
          iFeedbackShiftFrequencyHorizontalImpact:        () => visualizer.feedback.shift.frequency.horizontal.impact,
          iFeedbackShiftFrequencyHorizontalRangeMin:      () => visualizer.feedback.shift.frequency.horizontal.range.min,
          iFeedbackShiftFrequencyHorizontalRangeMax:      () => visualizer.feedback.shift.frequency.horizontal.range.max,
          iFeedbackShiftFrequencyHorizontalRangeLogScale: () => visualizer.feedback.shift.frequency.horizontal.range.logScale,
          iFeedbackShiftFrequencyHorizontalLoudnessMin:   () => visualizer.feedback.shift.frequency.horizontal.loudness.min,
          iFeedbackShiftFrequencyHorizontalLoudnessMax:   () => visualizer.feedback.shift.frequency.horizontal.loudness.max,
          iFeedbackShiftFrequencyHorizontalLoudnessCurve: () => visualizer.feedback.shift.frequency.horizontal.loudness.curve,
          iFeedbackShiftFrequencyVerticalImpact:          () => visualizer.feedback.shift.frequency.vertical.impact,
          iFeedbackShiftFrequencyVerticalRangeMin:        () => visualizer.feedback.shift.frequency.vertical.range.min,
          iFeedbackShiftFrequencyVerticalRangeMax:        () => visualizer.feedback.shift.frequency.vertical.range.max,
          iFeedbackShiftFrequencyVerticalRangeLogScale:   () => visualizer.feedback.shift.frequency.vertical.range.logScale,
          iFeedbackShiftFrequencyVerticalLoudnessMin:     () => visualizer.feedback.shift.frequency.vertical.loudness.min,
          iFeedbackShiftFrequencyVerticalLoudnessMax:     () => visualizer.feedback.shift.frequency.vertical.loudness.max,
          iFeedbackShiftFrequencyVerticalLoudnessCurve:   () => visualizer.feedback.shift.frequency.vertical.loudness.curve,
          iFeedbackShiftWaveformHorizontalImpact:         () => visualizer.feedback.shift.waveform.horizontal.impact,
          iFeedbackShiftWaveformVerticalImpact:           () => visualizer.feedback.shift.waveform.vertical.impact,

          iDrawShapeFrequencyImpact:                      () => visualizer.draw.shape.frequency.impact,
          iDrawShapeFrequencyRangeMin:                    () => visualizer.draw.shape.frequency.range.min,
          iDrawShapeFrequencyRangeMax:                    () => visualizer.draw.shape.frequency.range.max,
          iDrawShapeFrequencyRangeLogScale:               () => visualizer.draw.shape.frequency.range.logScale,
          iDrawShapeFrequencyLoudnessMin:                 () => visualizer.draw.shape.frequency.loudness.min,
          iDrawShapeFrequencyLoudnessMax:                 () => visualizer.draw.shape.frequency.loudness.max,
          iDrawShapeFrequencyLoudnessCurve:               () => visualizer.draw.shape.frequency.loudness.curve,
          iDrawShapeFrequencyPhase:                       () => visualizer.draw.shape.frequency.angle / TWO_PI,

          iDrawShapeSliceFrequencyRangeMin:               () => visualizer.draw.shape.slice.frequency.range.min,
          iDrawShapeSliceFrequencyRangeMax:               () => visualizer.draw.shape.slice.frequency.range.max,
          iDrawShapeSliceFrequencyRangeLogScale:          () => visualizer.draw.shape.slice.frequency.range.logScale,
          iDrawShapeSliceFrequencyLoudnessMin:            () => visualizer.draw.shape.slice.frequency.loudness.min,
          iDrawShapeSliceFrequencyLoudnessMax:            () => visualizer.draw.shape.slice.frequency.loudness.max,
          iDrawShapeSliceFrequencyLoudnessCurve:          () => visualizer.draw.shape.slice.frequency.loudness.curve,
          iDrawShapeSliceFrequencyPhase:                  () => visualizer.draw.shape.slice.frequency.shift,

          iDrawNoiseSliceFrequencyRangeMin:               () => visualizer.draw.noise.slice.frequency.range.min,
          iDrawNoiseSliceFrequencyRangeMax:               () => visualizer.draw.noise.slice.frequency.range.max,
          iDrawNoiseSliceFrequencyRangeLogScale:          () => visualizer.draw.noise.slice.frequency.range.logScale,
          iDrawNoiseSliceFrequencyLoudnessMin:            () => visualizer.draw.noise.slice.frequency.loudness.min,
          iDrawNoiseSliceFrequencyLoudnessMax:            () => visualizer.draw.noise.slice.frequency.loudness.max,
          iDrawNoiseSliceFrequencyLoudnessCurve:          () => visualizer.draw.noise.slice.frequency.loudness.curve,
          iDrawNoiseSliceFrequencyPhase:                  () => visualizer.draw.noise.slice.frequency.shift
        }
      },
      noise: {
        texture: (gl, ctx) => {
          const width = ctx.resolution[0] / NOISE_TEXTURE_DIVIDER;
          const height = ctx.resolution[1] / NOISE_TEXTURE_DIVIDER;
          ctx.initHalfFloatRGBATexture(width, height);
          // the texture will be already of a quite high resolution, so linear filtering is not needed and NEAREST makes it faster to read
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          ctx.noiseResolution = [width, height];
          ctx.noiseMinDimension = Math.min(width, height);
          return {
            width: width,
            height: height
          }
        },
        uniforms: {
          iResolution:                    () => ctx.noiseResolution,
          iMinDimension:                  () => ctx.noiseMinDimension,
          iFeedbackNoiseImpact:           () => visualizer.feedback.noise.impact,
          iFeedbackNoiseScale:            () => visualizer.feedback.noise.scale,
          iFeedbackNoisePhase:            () => visualizer.feedback.noise.phase,
          iFeedbackNoiseShift:            () => visualizer.feedback.noise.shift,
          iDrawNoiseApply:                () => drawNoiseApply,
          iDrawNoiseScale:                () => visualizer.draw.noise.scale,
          iDrawNoiseShift:                () => visualizer.draw.noise.shift,
          iDrawNoisePhase:                () => visualizer.draw.noise.phase,
        }
      },
      feedback: {
        uniforms: {
          // screen
          iResolution:                    () => ctx.resolution,
          iMinDimension:                  () => minDimension,
          iScreenRatioHalf:               () => screenRatioHalf,

          // system
          iPreviousFrame:                 () => ctx.buffers.feedback,
          iAudioTexture:                  () => ctx.buffers.audio,
          iNoiseTexture:                  () => ctx.buffers.noise,

          // feedback
          iFeedbackRotationCenter:        () => visualizer.feedback.rotation.center,
          iFeedbackRotationAngle:         () => visualizer.feedback.rotation.angle,
          iFeedbackZoomCenter:            () => visualizer.feedback.zoom.center,
          iFeedbackZoomScale:             () => 1 - (1 / visualizer.feedback.zoom.scale),
          iFeedbackZoomFrequencyImpact:   () => visualizer.feedback.zoom.frequency.impact,
          iFeedbackZoomWaveformImpact:    () => visualizer.feedback.zoom.waveform.impact,
          iFeedbackShiftRate:             () => visualizer.feedback.shift.rate,
          iFeedbackShiftFrequencyHorizontalImpact: () => visualizer.feedback.shift.frequency.horizontal.impact,
          iFeedbackShiftFrequencyVerticalImpact:   () => visualizer.feedback.shift.frequency.vertical.impact,
          iFeedbackShiftWaveformHorizontalImpact:  () => visualizer.feedback.shift.waveform.horizontal.impact,
          iFeedbackShiftWaveformVerticalImpact:    () => visualizer.feedback.shift.waveform.vertical.impact,
          iFeedbackFadeColor:             () => visualizer.feedback.fade.color,
          iFeedbackNoiseApply:            () => (visualizer.feedback.noise.impact !== 0),

          // draw noise
          iDrawNoiseApply:                () => drawNoiseApply,
          iDrawNoiseMix:                  () => visualizer.draw.noise.mix,
          iDrawNoiseMixFactor:            () => visualizer.draw.noise.mixFactor,
          iDrawNoiseColor:                () => visualizer.draw.noise.color,
          iDrawNoiseSpectrumApply:        () => !isZeroVector(visualizer.draw.noise.spectrum.color),
          iDrawNoiseSpectrumColor:        () => visualizer.draw.noise.spectrum.color,
          iDrawNoiseSliceStart:           () => visualizer.draw.noise.slice.start,
          iDrawNoiseSliceEnd:             () => visualizer.draw.noise.slice.end,
          iDrawNoiseEdgeInnerStart:       () => visualizer.draw.noise.edge.inner.start,
          iDrawNoiseEdgeInnerEnd:         () => visualizer.draw.noise.edge.inner.end,
          iDrawNoiseEdgeOuterStart:       () => visualizer.draw.noise.edge.outer.start,
          iDrawNoiseEdgeOuterEnd:         () => visualizer.draw.noise.edge.outer.end,
          iDrawNoiseSliceFrequencyApply:  () => visualizer.draw.noise.slice.frequency.apply,
          iDrawNoisePaletteIntensity:     () => visualizer.draw.noise.palette.intensity,
          iDrawNoisePaletteA:             () => visualizer.draw.noise.palette.a,
          iDrawNoisePaletteB:             () => visualizer.draw.noise.palette.b,
          iDrawNoisePaletteC:             () => visualizer.draw.noise.palette.c,
          iDrawNoisePaletteD:             () => visualizer.draw.noise.palette.d,

          // draw shape
          iDrawShapeApply:                isDrawShapeApply,
          iDrawShapeMix:                  () => visualizer.draw.shape.mix,
          iDrawShapeMixFactor:            () => visualizer.draw.shape.mixFactor,
          iDrawShapeColor:                () => visualizer.draw.shape.color,
          iDrawShapeSpectrumApply:        () => !isZeroVector(visualizer.draw.shape.spectrum.color),
          iDrawShapeSpectrumColor:        () => visualizer.draw.shape.spectrum.color,
          iDrawShapeCenter:               () => visualizer.draw.shape.center,
          iDrawShapeVertices:             () => visualizer.draw.shape.vertices,
          iDrawShapeSize:                 () => visualizer.draw.shape.size,
          iDrawShapeAngle:                () => visualizer.draw.shape.angle,
          iDrawShapeSliceStart:           () => visualizer.draw.shape.slice.start,
          iDrawShapeSliceEnd:             () => visualizer.draw.shape.slice.end,
          iDrawShapeEdgeInnerStart:       () => visualizer.draw.shape.edge.inner.start,
          iDrawShapeEdgeInnerEnd:         () => visualizer.draw.shape.edge.inner.end,
          iDrawShapeEdgeOuterStart:       () => visualizer.draw.shape.edge.outer.start,
          iDrawShapeEdgeOuterEnd:         () => visualizer.draw.shape.edge.outer.end,
          iDrawShapeFrequencyApply:       () => (visualizer.draw.shape.frequency.impact !== 0),
          iDrawShapeSliceFrequencyApply:  () => visualizer.draw.shape.slice.frequency.apply,
          iDrawShapePaletteIntensity:     () => visualizer.draw.shape.palette.intensity,
          iDrawShapePaletteA:             () => visualizer.draw.shape.palette.a,
          iDrawShapePaletteB:             () => visualizer.draw.shape.palette.b,
          iDrawShapePaletteC:             () => visualizer.draw.shape.palette.c,
          iDrawShapePaletteD:             () => visualizer.draw.shape.palette.d
        }
      },
      image: {
        uniforms: {
          // screen
          iResolution:                    () => ctx.resolution,
          iMinDimension:                  () => minDimension,
          iScreenRatioHalf:               () => screenRatioHalf,

          // colors
          iColorGammaCorrection:          () => visualizer.color.gammaCorrection,
          iColorInvert:                   () => visualizer.color.invert,

          // system
          iFeedbackTexture:               () => ctx.buffers.feedback,

          // ripple
          iRippleCenter:                  () => visualizer.ripple.center,
          iRippleImpact:                  () => visualizer.ripple.impact,
          iRippleScale:                   () => visualizer.ripple.scale * TWO_PI,
          iRipplePhase:                   () => visualizer.ripple.phase * TWO_PI,

          // glass
          iGlassApply:                    () => (visualizer.glass.refraction > 0) || (visualizer.glass.color.impact > 0),
          iGlassRefraction:               () => visualizer.glass.refraction,
          iGlassColorImpact:              () => visualizer.glass.color.impact,
          iGlassColorBase:                () => visualizer.glass.color.base,
          iGlassColorTint:                () => visualizer.glass.color.tint,
          iGlassCenter:                   () => visualizer.glass.center,
          iGlassVertices:                 () => visualizer.glass.vertices,
          iGlassWidth:                    () => visualizer.glass.width,
          iGlassEdgeWidth:                () => visualizer.glass.edge.width,
          iGlassEdgeThickness:            () => visualizer.glass.edge.thickness,
          iGlassEdgeSmoothing:            () => visualizer.glass.edge.smoothing,
          iGlassAngle:                    () => visualizer.glass.angle,
          iGlassPhase:                    () => visualizer.glass.phase,
          iGlassPerspective:              () => visualizer.glass.perspective,
          iGlassFade:                     () => visualizer.glass.fade,
          iGlassScale:                    () => visualizer.glass.scale
        }
      }
    }
  }
});
        });

        return {
          visualizerApi: visualizerApi,
          visualizer: visualizer,
          controls: controls,
          controlsMetadata: controlsMetadata,
          experience: experience,
          music: music,
          newDefaultExperience: newDefaultExperience,
          mapControlsToVisualizer: mapControlsToVisualizer
        };
      })();

      const designer = (() => {

        function newDesigner(
  visualizerApi,
  visualizer,
  controls,
  controlsMetadata,
  experience,
  music,
  mapControlsToVisualizer
) {

  const VECTOR_COMPONENTS = ["x", "y", "z", "w"];

  function populateEditorWithMapping() {
    getElement("mapping-editor").value = getFunctionBody(visualizer.mapping);
  }

  function initEditor() {
    const editor = getElement("mapping-editor");
    const errorConsole = getElement("mapping-errors");
    const applyMapping = () => {
      errorConsole.innerHTML = "";
      try {
        visualizerApi.setMapping(editor.value);
      } catch (e) {
        errorConsole.innerHTML = e;
      }
    };
    when("action-apply-mapping", "click", applyMapping);
    when(editor, "keydown", (e) => {
      if (e.key === "Enter" && e.metaKey) {
        applyMapping();
      }
    });
  }

  function initUi(controlsUpdater) {

    // const actionCopyState = getElement("action-copy-state");

    when("select-preview", "change", (event) => {
      document.body.className = "preview-" + event.target.value;
    });

    when("experience-title", "change", (event) => {
      experience.title = event.target.value;
    });

    when("experience-description", "change", (event) => {
      experience.description = event.target.value;
    });

    getElement("default-mapping-reference").innerHTML = getFunctionBody(mapControlsToVisualizer).replaceAll("\n  ", "\n");
  }

  const updateChildren = (children) => children.forEach((child) => child.update());

  const newFloatSlider = (controlsNode, name, min, max, updateDisplay) => slider(min, max).also((slider) => {
    slider.oninput = () => {
      const value = parseFloat(slider.value);
      controlsNode[name] = value;
      updateDisplay(value);
    };
    slider.update = () => {
      const value = controlsNode[name];
      slider.value = value;
      updateDisplay(value);
    };
  });

  const newIndexedFloatSlider = (controlsNode, name, index, min, max, updateDisplay) => slider(min, max).also((slider) => {
    slider.oninput = () => {
      const value = parseFloat(slider.value);
      controlsNode[name][index] = value;
      updateDisplay(value);
    };
    slider.update = () => {
      const value = controlsNode[name][index];
      slider.value = value;
      updateDisplay(value)
    };
  });

  const newIntegerSlider = (controlsNode, name, min, max, updateDisplay) => slider(min, max, 1).also((slider) => {
    slider.oninput = () => {
      const value = parseFloat(slider.value);
      controlsNode[name] = value;
      updateDisplay(value);
    };
    slider.update = () => {
      const value = controlsNode[name];
      slider.value = value;
      updateDisplay(value);
    };
  });

  const newProperty = (name, newSlider, format) => div("property").also((container) => {
    const valueBox = div("value");
    const slider = newSlider((value) => {
      valueBox.innerText = format(value);
    });
    container.appendChildren([div("label", name), valueBox, slider]);
    container.update = () => {
      slider.update();
    };
  });

  const newFloatProperty = (controlsNode, name, metadata) => newProperty(
    name,
    (updateDisplay) => newFloatSlider(controlsNode, name, metadata[0], metadata[1], updateDisplay),
    (metadata[4] && (typeof(metadata[4]) === 'function')) ? metadata[4] : ((x) => formatNumber(x))
  );

  const newIntegerProperty = (controlsNode, name, metadata) => newProperty(
    name,
    (updateDisplay) => newIntegerSlider(controlsNode, name, metadata[1], metadata[2], updateDisplay),
    (metadata[5] && (typeof(metadata[5]) === 'function')) ? metadata[5] : ((x) => "" + x)
  );

  const newVectorComponent = (controlsNode, name, index, min, max, componentNames, updateParentDisplay) => newProperty(
    componentNames[index],
    (updateDisplay) => newIndexedFloatSlider(controlsNode, name, index, min, max, (value) => {
      updateDisplay(value);
      if (updateParentDisplay) {
         updateParentDisplay(index, value);
      }
    }),
    (x) => formatNumber(x)
  );

  function setDepth(container, depth) {
    container.style = "--depth:" + depth + ";"
  }

  const newVectorProperty = (controlsNode, name, metadata, depth) => details(name).also((container) => {
    setDepth(container, depth);
    const children = metadata[2].map((component, index) =>
      newVectorComponent(controlsNode, name, index, metadata[0][index], metadata[1][index], VECTOR_COMPONENTS),
    );
    container.appendChild(div("child-controls", children));
    container.update = () => updateChildren(children);
  });

  const vectorToCssRgb = (x) => "rgb(" + x.map(xi => Math.round(xi * 255)).join(",") + ")";

  const hexToVector = (hex) => hex.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, (m, r, g, b) => '#' + r + r + g + g + b + b)
      .substring(1).match(/.{2}/g)
      .map(x => parseInt(x, 16))
      .map(x => x / 255);

  const vectorToHex = (x) => "#" + x.map(x => Math.round(x * 255)).map(x => {
    const hex = x.toString(16)
    return hex.length === 1 ? "0" + hex : hex
  }).join("");

  const newColorProperty = (controlsNode, name) => div("property").also((container) => {
    const picker = newElement("input");
    picker.type = "color";
    when(picker, "input", () => {
      controlsNode[name] = hexToVector(picker.value);
    });
    container.appendChildren([div("label", name), picker]);
    container.update = () => {
      picker.value = vectorToHex(controlsNode[name]);
    };
  });

  const newBooleanProperty = (controlsNode, name, metadata) => div("property").also((container) => {
    const checkbox = newElement("input");
    checkbox.type = "checkbox";
    when(checkbox, "input", () => {
      controlsNode[name] = checkbox.checked;
    });
    container.appendChildren([div("label", name), checkbox]);
    container.update = () => {
      checkbox.checked = controlsNode[name];
    };
  });

  function addControl(controlsNode, name, metadata, path, depth) {
    if (metadata instanceof Array) {
      if (typeof metadata[0] === "number") {
        return newFloatProperty(controlsNode, name, metadata);
      } else if (typeof metadata[0] === "string") {
        if (metadata[0] === "color") {
          return newColorProperty(controlsNode, name);
        } else if (metadata[0] === "boolean") {
          return newBooleanProperty(controlsNode, name, metadata);
        } else if (metadata[0] === "integer") {
          return newIntegerProperty(controlsNode, name, metadata);
        }
      } else if (metadata[0] instanceof Array) { // number, therefore vector
        return newVectorProperty(controlsNode, name, metadata, depth);
      } else {
        return div("Unsupported metadata type on path, fix it: " + path);
      }
    } else {
      return addControls(controlsNode[name], name, metadata, path + "." + name, depth);
    }
  }

  function addControls(controlsNode, name, metadata, path, depth) {
    const children = toArray(
      metadata, (key, value) => addControl(controlsNode, key, value, path, depth + 1)
    );
    const container = details(
      name,
      div("child-controls", children)
    );
    container.id = path;
    setDepth(container, depth);
    container.update = () => updateChildren(children);
    return container;
  }

  const newMusicStateProperty = (musicStateNode, name) => div("property").also((container) => {
    const valueBox = div("value", musicStateNode[name]);
    container.appendChildren([div("label", name), valueBox]);
    container.update = () => {
      const value = musicStateNode[name];
      valueBox.innerText = (typeof value === "number") ? value.toFixed(1) : value;
    };
  });

  function addMusicStateProperty(musicStateNode, name, path, depth) {
    const value = musicStateNode[name];
    if (typeof value === "object") {
      return addMusicStateGroup(value, name, path + "." + name, depth);
    } else {
      return newMusicStateProperty(musicStateNode, name);
    }
  }

  function addMusicStateGroup(musicStateNode, name, path, depth) {
    const children = toArray(
      musicStateNode, (key, value) => addMusicStateProperty(musicStateNode, key, path, depth + 1)
    );
    const container = details(
      name,
      div("child-controls", children)
    );
    container.id = path;
    setDepth(container, depth);
    container.update = () => updateChildren(children);
    return container;
  }

  // TODO extract common code
  function shadeAnalyserFrequency(canvas, defaultSize, initialValue, masterRenderer) {
    shaderWebBackground.shade((ctx) => {
      let renderer;
      return {
        canvas: canvas,
        onInit: () => {
          renderer = new TextureRenderer(ctx.gl, defaultSize, initialValue);
          renderer.data = masterRenderer.data;
        },
        onBeforeFrame: () => {
          if (renderer.size !== masterRenderer.size) {
            renderer.resize(masterRenderer.size);
            renderer.data = masterRenderer.data;
          }
          renderer.render();
        },
        shaders: {
          analyserFrequency: {
            uniforms: {
              iResolution:                () => ctx.resolution,
              iAnalyserFrequencyTexture:  () => renderer.getTexture(),
              iAnalyserFrequencyLogScale: () => visualizer.analyser.frequency.logScale
            }
          }
        }
      }
    });
  }

  function shadeAnalyserWaveform(canvas, defaultSize, initialValue, masterRenderer) {
    shaderWebBackground.shade((ctx) => {
      let renderer;
      return {
        canvas: canvas,
        onInit: () => {
          renderer = new TextureRenderer(ctx.gl, defaultSize, initialValue);
          renderer.data = masterRenderer.data;
        },
        onBeforeFrame: () => {
          if (renderer.size !== masterRenderer.size) {
            renderer.resize(masterRenderer.size);
            renderer.data = masterRenderer.data;
          }
          renderer.render();
        },
        shaders: {
          analyserWaveform: {
            uniforms: {
              iResolution:              () => ctx.resolution,
              iAnalyserWaveformTexture: () => renderer.getTexture()
            }
          }
        }
      }
    });
  }

  function addAnalyserView(audioDataRenderer) {
    const leftFrequenciesCanvas = newElement("canvas", "analyser-preview");
    const rightFrequenciesCanvas = newElement("canvas", "analyser-preview");
    const waveformCanvas = newElement("canvas", "analyser-preview");
    const frequenciesPreview = div(
      "frequencies-preview", [leftFrequenciesCanvas, rightFrequenciesCanvas]
    );
    getElement("controls.analyser.frequency")
      .querySelector(".child-controls")
      .insertAdjacentElement("afterbegin", frequenciesPreview);
    getElement("controls.analyser.waveform")
      .querySelector(".child-controls")
      .insertAdjacentElement("afterbegin", waveformCanvas);
    shadeAnalyserFrequency(leftFrequenciesCanvas, 2048, 0, audioDataRenderer.leftFrequencies);
    shadeAnalyserFrequency(rightFrequenciesCanvas, 2048, 0, audioDataRenderer.rightFrequencies);
    shadeAnalyserWaveform(waveformCanvas, 1024, .5, audioDataRenderer.waveform);

  //  const zoomFrequencyShader = getElement("controls.analyser.waveform")
  //    .querySelector(".child-controls")
  //    .insertAdjacentElement("afterbegin", waveformCanvas);
  //  getElement("controls.feedback.zoom.frequency")
  //    .querySelector(".child-controls")
  //    .insertAdjacentElement("afterbegin", waveformCanvas);
  }

  let musicStateDisplay;

  let titleBox;
  let descriptionBox;
  let controlsUpdater;

  function initDesigner(audioDataRenderer) {
    titleBox = getElement("experience-title");
    descriptionBox = getElement("experience-description");
    const controlsUi = addControls(controls, "controls", controlsMetadata, "controls", 0);
    musicStateDisplay = addMusicStateGroup(music, "music", "music", 0);
    controlsUi.open = true;
    getElement("controls-tree").appendChild(controlsUi);
    getElement("music").appendChild(musicStateDisplay);
    controlsUpdater = () => controlsUi.update();
    initUi(controlsUpdater);
    initEditor();
    addAnalyserView(audioDataRenderer);
  }

  return {
    initialize: (audioDataRenderer) => {
      initDesigner(audioDataRenderer);
    },
    updateOnExperience: () => {
      titleBox.value = experience.title;
      descriptionBox.value = experience.description;
      controlsUpdater();
      populateEditorWithMapping();
    },
    updateOnEachFrame: () => {
      musicStateDisplay.update();
    }
  };

}

        return newDesigner(
          visualizer.visualizerApi,
          visualizer.visualizer,
          visualizer.controls,
          visualizer.controlsMetadata,
          visualizer.experience,
          visualizer.music,
          visualizer.mapControlsToVisualizer
        );
      })();

      const getCanvas = () => getElement("preview");
let audioContext;

function initialize(audioAnalyser, aimiDataRenderer, visualizerApi) {
  const audio = getElement("audio-track");

  var micStream = null

    const handleSuccess = function(stream) {
      micStream = stream;
      if (window.URL) {
        console.log("window.URL");
        //audio.src = URL.createObjectURL(stream);
        audio.srcObject = stream;
      } else {
        playaudioer.src = stream;
      }
      audio.play();
    };

    navigator.mediaDevices.getUserMedia({ audio: true, video: false })
        .then(handleSuccess);


  when(audio, "play", (event) => {
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const source = !micStream
        ? audioContext.createMediaElementSource(audio)
        : audioContext.createMediaStreamSource(micStream);
      audioAnalyser.start(audioContext, source);
      source.connect(audioContext.destination)
    }
  });
  when("audio-file", "change", (event) => {
    const file = URL.createObjectURL(event.target.files[0]);
    audio.src = file;
    audio.play();
  });
  when("action-copy-state", "click", () => {
    const exported = visualizerApi.getCurrentVisualizerManifest();
    navigator.clipboard.writeText(exported);
  });

  initExperienceSwitcher(visualizerApi);
  designer.initialize(aimiDataRenderer);
  designer.updateOnExperience();
}

function onEachFrame() {
  designer.updateOnEachFrame();
}

      // FIXME This logic has been separated, because once experience manifests are stored externally, this code should be removed (but it is still used in the player target)

function initExperienceSwitcher(visualizerApi) {

  const selectExperience = getElement("select-experience");

  for (const id in experiences) {
    selectExperience.appendChild(option(id, id));
  }

  when(selectExperience, "change", (event) => {
    const experienceId = selectExperience.value;
    const manifest = experiences[experienceId];
    visualizerApi.startExperience(manifest);
    designer.updateOnExperience();
  });

}
      const experiences = {
        "default": visualizer.newDefaultExperience(),
        "aimi-level-0":{
  "title": "Serenity",
  "description": "Soothing sounds to help you reduce stress and calm your mind. Activate a state of calm and relaxation. Our Serenity experience is the place to do it. Flowing soundscapes and meditative beats are backed by science and infused with sounds of nature and soothing instruments. Experience Serenity by AiMi.",
  "controls": {
    "analyser": {
      "frequency": {
        "samples": 10,
        "stereo": true,
        "smoothing": 0.8,
        "logScale": false
      },
      "waveform": {
        "samples": 11
      }
    },
    "color": {
      "gammaCorrection": 1,
      "invert": false
    },
    "feedback": {
      "fade": {
        "rate": 0.95,
        "color": [
          1,
          1,
          1
        ]
      },
      "rotation": {
        "center": [
          0,
          0
        ],
        "angle": 0
      },
      "zoom": {
        "center": [
          0,
          0
        ],
        "scale": 1,
        "frequency": {
          "impact": 0,
          "range": {
            "min": 0,
            "max": 1,
            "logScale": false
          },
          "loudness": {
            "min": -100,
            "max": -30,
            "curve": 1
          },
          "angle": 0
        },
        "waveform": {
          "impact": 0,
          "mirror": true,
          "angle": 0
        }
      },
      "shift": {
        "rate": [
          0,
          0
        ],
        "frequency": {
          "horizontal": {
            "impact": 0,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            }
          },
          "vertical": {
            "impact": 0,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            }
          }
        },
        "waveform": {
          "horizontal": {
            "impact": 0
          },
          "vertical": {
            "impact": 0
          }
        }
      },
      "noise": {
        "impact": 0,
        "scale": 1,
        "phase": 0,
        "shift": [
          0,
          0
        ],
        "speed": {
          "phase": 0.2,
          "shift": [
            0,
            0
          ]
        }
      }
    },
    "draw": {
      "noise": {
        "mix": false,
        "intensity": 0,
        "color": [
          1,
          1,
          1
        ],
        "scale": 1,
        "phase": 0,
        "shift": [
          0,
          0
        ],
        "slice": {
          "start": 0,
          "end": 0.5,
          "frequency": {
            "apply": false,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            },
            "shift": 0
          }
        },
        "edge": {
          "inner": {
            "start": 0,
            "end": 0.0001
          },
          "outer": {
            "start": 0.4999,
            "end": 0.5
          }
        },
        "spectrum": {
          "intensity": 0,
          "color": [
            1,
            1,
            1
          ]
        },
        "palette": {
          "intensity": 0,
          "a": [
            0.5,
            0.5,
            0.5
          ],
          "b": [
            0.5,
            0.5,
            0.5
          ],
          "c": [
            1,
            1,
            1
          ],
          "d": [
            0,
            0.33,
            0.67
          ]
        },
        "speed": {
          "phase": 0.2,
          "shift": [
            0,
            0
          ]
        }
      },
      "shape": {
        "mix": false,
        "intensity": 1,
        "color": [
          1,
          1,
          1
        ],
        "center": [
          0,
          0
        ],
        "vertices": 1,
        "size": 0.618033,
        "angle": 0,
        "slice": {
          "start": 0.97,
          "end": 1,
          "frequency": {
            "apply": false,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            },
            "shift": 0
          }
        },
        "edge": {
          "inner": {
            "start": 0.96,
            "end": 0.97
          },
          "outer": {
            "start": 0.99,
            "end": 1
          }
        },
        "spectrum": {
          "intensity": 0,
          "color": [
            1,
            1,
            1
          ]
        },
        "palette": {
          "intensity": 0,
          "a": [
            0.5,
            0.5,
            0.5
          ],
          "b": [
            0.5,
            0.5,
            0.5
          ],
          "c": [
            1,
            1,
            1
          ],
          "d": [
            0,
            0.33,
            0.67
          ]
        },
        "frequency": {
          "impact": 0,
          "range": {
            "min": 0,
            "max": 1,
            "logScale": false
          },
          "loudness": {
            "min": -100,
            "max": -30,
            "curve": 1
          },
          "angle": 0
        },
        "speed": {
          "rotation": 0.1
        }
      }
    },
    "ripple": {
      "impact": 0,
      "center": [
        0,
        0
      ],
      "scale": 5,
      "phase": 0,
      "speed": {
        "phase": 1
      }
    },
    "glass": {
      "refraction": 0,
      "color": {
        "impact": 0,
        "base": [
          1,
          1,
          1
        ],
        "tint": [
          1,
          1,
          1
        ]
      },
      "center": [
        0,
        0
      ],
      "vertices": 0,
      "width": 0.5,
      "edge": {
        "width": 0.1,
        "thickness": 0.1,
        "smoothing": 0.05
      },
      "angle": 0,
      "phase": 0,
      "fade": 1,
      "perspective": false,
      "scale": 1,
      "speed": {
        "phase": 1,
        "rotation": 0.1
      }
    }
  },
  "mapping": "visualizer.draw.shape.size = controls.draw.shape.size + cos(music.beat.period(1)) * .1;\n"
},"aimi-level-1":{
  "title": "Flow",
  "description": "Lo-fi beats that keep you engaged and centered so you can flow with focus. Sometimes life is better without distractions. Select our Flow experience to keep centered, tune out the world and tune into your own flow.",
  "controls": {
    "analyser": {
      "frequency": {
        "samples": 10,
        "stereo": true,
        "smoothing": 0.8,
        "logScale": false
      },
      "waveform": {
        "samples": 11
      }
    },
    "color": {
      "gammaCorrection": 1,
      "invert": false
    },
    "feedback": {
      "fade": {
        "rate": 0.95,
        "color": [
          1,
          1,
          1
        ]
      },
      "rotation": {
        "center": [
          0,
          0
        ],
        "angle": 0
      },
      "zoom": {
        "center": [
          0,
          0
        ],
        "scale": 1,
        "frequency": {
          "impact": 0,
          "range": {
            "min": 0,
            "max": 1,
            "logScale": false
          },
          "loudness": {
            "min": -100,
            "max": -30,
            "curve": 1
          },
          "angle": 0
        },
        "waveform": {
          "impact": 0,
          "mirror": true,
          "angle": 0
        }
      },
      "shift": {
        "rate": [
          0,
          0
        ],
        "frequency": {
          "horizontal": {
            "impact": 0,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            }
          },
          "vertical": {
            "impact": 0,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            }
          }
        },
        "waveform": {
          "horizontal": {
            "impact": 0
          },
          "vertical": {
            "impact": 0
          }
        }
      },
      "noise": {
        "impact": 0,
        "scale": 1,
        "phase": 0,
        "shift": [
          0,
          0
        ],
        "speed": {
          "phase": 0.2,
          "shift": [
            0,
            0
          ]
        }
      }
    },
    "draw": {
      "noise": {
        "mix": false,
        "intensity": 0,
        "color": [
          1,
          1,
          1
        ],
        "scale": 1,
        "phase": 0,
        "shift": [
          0,
          0
        ],
        "slice": {
          "start": 0,
          "end": 0.5,
          "frequency": {
            "apply": false,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            },
            "shift": 0
          }
        },
        "edge": {
          "inner": {
            "start": 0,
            "end": 0.0001
          },
          "outer": {
            "start": 0.4999,
            "end": 0.5
          }
        },
        "spectrum": {
          "intensity": 0,
          "color": [
            1,
            1,
            1
          ]
        },
        "palette": {
          "intensity": 0,
          "a": [
            0.5,
            0.5,
            0.5
          ],
          "b": [
            0.5,
            0.5,
            0.5
          ],
          "c": [
            1,
            1,
            1
          ],
          "d": [
            0,
            0.33,
            0.67
          ]
        },
        "speed": {
          "phase": 0.2,
          "shift": [
            0,
            0
          ]
        }
      },
      "shape": {
        "mix": false,
        "intensity": 1,
        "color": [
          1,
          1,
          1
        ],
        "center": [
          0,
          0
        ],
        "vertices": 2,
        "size": 0.618033,
        "angle": 0,
        "slice": {
          "start": 0.97,
          "end": 1,
          "frequency": {
            "apply": false,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            },
            "shift": 0
          }
        },
        "edge": {
          "inner": {
            "start": 0.96,
            "end": 0.97
          },
          "outer": {
            "start": 0.99,
            "end": 1
          }
        },
        "spectrum": {
          "intensity": 0,
          "color": [
            1,
            1,
            1
          ]
        },
        "palette": {
          "intensity": 0,
          "a": [
            0.5,
            0.5,
            0.5
          ],
          "b": [
            0.5,
            0.5,
            0.5
          ],
          "c": [
            1,
            1,
            1
          ],
          "d": [
            0,
            0.33,
            0.67
          ]
        },
        "frequency": {
          "impact": 0,
          "range": {
            "min": 0,
            "max": 1,
            "logScale": false
          },
          "loudness": {
            "min": -100,
            "max": -30,
            "curve": 1
          },
          "angle": 0
        },
        "speed": {
          "rotation": 0.1
        }
      }
    },
    "ripple": {
      "impact": 0,
      "center": [
        0,
        0
      ],
      "scale": 5,
      "phase": 0,
      "speed": {
        "phase": 1
      }
    },
    "glass": {
      "refraction": 0,
      "color": {
        "impact": 0,
        "base": [
          1,
          1,
          1
        ],
        "tint": [
          1,
          1,
          1
        ]
      },
      "center": [
        0,
        0
      ],
      "vertices": 5,
      "width": 0.5,
      "edge": {
        "width": 0.1,
        "thickness": 0.1,
        "smoothing": 0.05
      },
      "angle": 0,
      "phase": 0,
      "fade": 1,
      "perspective": false,
      "scale": 1,
      "speed": {
        "phase": 1,
        "rotation": 0.1
      }
    }
  },
  "mapping": "visualizer.draw.shape.size = controls.draw.shape.size + cos(music.beat.period(1)) * .1;\n"
},"aimi-level-2":{
  "title": "Chill",
  "description": "Chill vibes with just enough groove to put a smile on your face. When the days are long and the stress is high, our Chill experience is the remedy. You’ll get just enough groove to move by and a feeling to lighten your day.",
  "controls": {
    "analyser": {
      "frequency": {
        "samples": 10,
        "stereo": true,
        "smoothing": 0.8,
        "logScale": false
      },
      "waveform": {
        "samples": 11
      }
    },
    "color": {
      "gammaCorrection": 1,
      "invert": false
    },
    "feedback": {
      "fade": {
        "rate": 0.95,
        "color": [
          1,
          1,
          1
        ]
      },
      "rotation": {
        "center": [
          0,
          0
        ],
        "angle": 0
      },
      "zoom": {
        "center": [
          0,
          0
        ],
        "scale": 1,
        "frequency": {
          "impact": 0,
          "range": {
            "min": 0,
            "max": 1,
            "logScale": false
          },
          "loudness": {
            "min": -100,
            "max": -30,
            "curve": 1
          },
          "angle": 0
        },
        "waveform": {
          "impact": 0,
          "mirror": true,
          "angle": 0
        }
      },
      "shift": {
        "rate": [
          0,
          0
        ],
        "frequency": {
          "horizontal": {
            "impact": 0,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            }
          },
          "vertical": {
            "impact": 0,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            }
          }
        },
        "waveform": {
          "horizontal": {
            "impact": 0
          },
          "vertical": {
            "impact": 0
          }
        }
      },
      "noise": {
        "impact": 0,
        "scale": 1,
        "phase": 0,
        "shift": [
          0,
          0
        ],
        "speed": {
          "phase": 0.2,
          "shift": [
            0,
            0
          ]
        }
      }
    },
    "draw": {
      "noise": {
        "mix": false,
        "intensity": 0,
        "color": [
          1,
          1,
          1
        ],
        "scale": 1,
        "phase": 0,
        "shift": [
          0,
          0
        ],
        "slice": {
          "start": 0,
          "end": 0.5,
          "frequency": {
            "apply": false,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            },
            "shift": 0
          }
        },
        "edge": {
          "inner": {
            "start": 0,
            "end": 0.0001
          },
          "outer": {
            "start": 0.4999,
            "end": 0.5
          }
        },
        "spectrum": {
          "intensity": 0,
          "color": [
            1,
            1,
            1
          ]
        },
        "palette": {
          "intensity": 0,
          "a": [
            0.5,
            0.5,
            0.5
          ],
          "b": [
            0.5,
            0.5,
            0.5
          ],
          "c": [
            1,
            1,
            1
          ],
          "d": [
            0,
            0.33,
            0.67
          ]
        },
        "speed": {
          "phase": 0.2,
          "shift": [
            0,
            0
          ]
        }
      },
      "shape": {
        "mix": false,
        "intensity": 1,
        "color": [
          1,
          1,
          1
        ],
        "center": [
          0,
          0
        ],
        "vertices": 3,
        "size": 0.618033,
        "angle": 0,
        "slice": {
          "start": 0.97,
          "end": 1,
          "frequency": {
            "apply": false,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            },
            "shift": 0
          }
        },
        "edge": {
          "inner": {
            "start": 0.96,
            "end": 0.97
          },
          "outer": {
            "start": 0.99,
            "end": 1
          }
        },
        "spectrum": {
          "intensity": 0,
          "color": [
            1,
            1,
            1
          ]
        },
        "palette": {
          "intensity": 0,
          "a": [
            0.5,
            0.5,
            0.5
          ],
          "b": [
            0.5,
            0.5,
            0.5
          ],
          "c": [
            1,
            1,
            1
          ],
          "d": [
            0,
            0.33,
            0.67
          ]
        },
        "frequency": {
          "impact": 0,
          "range": {
            "min": 0,
            "max": 1,
            "logScale": false
          },
          "loudness": {
            "min": -100,
            "max": -30,
            "curve": 1
          },
          "angle": 0
        },
        "speed": {
          "rotation": 0.1
        }
      }
    },
    "ripple": {
      "impact": 0,
      "center": [
        0,
        0
      ],
      "scale": 5,
      "phase": 0,
      "speed": {
        "phase": 1
      }
    },
    "glass": {
      "refraction": 0,
      "color": {
        "impact": 0,
        "base": [
          1,
          1,
          1
        ],
        "tint": [
          1,
          1,
          1
        ]
      },
      "center": [
        0,
        0
      ],
      "vertices": 5,
      "width": 0.5,
      "edge": {
        "width": 0.1,
        "thickness": 0.1,
        "smoothing": 0.05
      },
      "angle": 0,
      "phase": 0,
      "fade": 1,
      "perspective": false,
      "scale": 1,
      "speed": {
        "phase": 1,
        "rotation": 0.1
      }
    }
  },
  "mapping": "visualizer.draw.shape.size = controls.draw.shape.size + cos(music.beat.period(1)) * .1;\n"
},"aimi-level-3":{
  "title": "Lounge",
  "description": "Transport yourself to a favorite beach club or lounge. Lounge is a sense of place. A sense of escape. A sense of being somewhere you’d always rather be — whether it’s a favorite beach club, lounge or poolside terrace.",
  "controls": {
    "analyser": {
      "frequency": {
        "samples": 10,
        "stereo": true,
        "smoothing": 0.8,
        "logScale": false
      },
      "waveform": {
        "samples": 11
      }
    },
    "color": {
      "gammaCorrection": 1,
      "invert": false
    },
    "feedback": {
      "fade": {
        "rate": 0.95,
        "color": [
          1,
          1,
          1
        ]
      },
      "rotation": {
        "center": [
          0,
          0
        ],
        "angle": 0
      },
      "zoom": {
        "center": [
          0,
          0
        ],
        "scale": 1,
        "frequency": {
          "impact": 0,
          "range": {
            "min": 0,
            "max": 1,
            "logScale": false
          },
          "loudness": {
            "min": -100,
            "max": -30,
            "curve": 1
          },
          "angle": 0
        },
        "waveform": {
          "impact": 0,
          "mirror": true,
          "angle": 0
        }
      },
      "shift": {
        "rate": [
          0,
          0
        ],
        "frequency": {
          "horizontal": {
            "impact": 0,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            }
          },
          "vertical": {
            "impact": 0,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            }
          }
        },
        "waveform": {
          "horizontal": {
            "impact": 0
          },
          "vertical": {
            "impact": 0
          }
        }
      },
      "noise": {
        "impact": 0,
        "scale": 1,
        "phase": 0,
        "shift": [
          0,
          0
        ],
        "speed": {
          "phase": 0.2,
          "shift": [
            0,
            0
          ]
        }
      }
    },
    "draw": {
      "noise": {
        "mix": false,
        "intensity": 0,
        "color": [
          1,
          1,
          1
        ],
        "scale": 1,
        "phase": 0,
        "shift": [
          0,
          0
        ],
        "slice": {
          "start": 0,
          "end": 0.5,
          "frequency": {
            "apply": false,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            },
            "shift": 0
          }
        },
        "edge": {
          "inner": {
            "start": 0,
            "end": 0.0001
          },
          "outer": {
            "start": 0.4999,
            "end": 0.5
          }
        },
        "spectrum": {
          "intensity": 0,
          "color": [
            1,
            1,
            1
          ]
        },
        "palette": {
          "intensity": 0,
          "a": [
            0.5,
            0.5,
            0.5
          ],
          "b": [
            0.5,
            0.5,
            0.5
          ],
          "c": [
            1,
            1,
            1
          ],
          "d": [
            0,
            0.33,
            0.67
          ]
        },
        "speed": {
          "phase": 0.2,
          "shift": [
            0,
            0
          ]
        }
      },
      "shape": {
        "mix": false,
        "intensity": 1,
        "color": [
          1,
          1,
          1
        ],
        "center": [
          0,
          0
        ],
        "vertices": 4,
        "size": 0.618033,
        "angle": 0,
        "slice": {
          "start": 0.97,
          "end": 1,
          "frequency": {
            "apply": false,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            },
            "shift": 0
          }
        },
        "edge": {
          "inner": {
            "start": 0.96,
            "end": 0.97
          },
          "outer": {
            "start": 0.99,
            "end": 1
          }
        },
        "spectrum": {
          "intensity": 0,
          "color": [
            1,
            1,
            1
          ]
        },
        "palette": {
          "intensity": 0,
          "a": [
            0.5,
            0.5,
            0.5
          ],
          "b": [
            0.5,
            0.5,
            0.5
          ],
          "c": [
            1,
            1,
            1
          ],
          "d": [
            0,
            0.33,
            0.67
          ]
        },
        "frequency": {
          "impact": 0,
          "range": {
            "min": 0,
            "max": 1,
            "logScale": false
          },
          "loudness": {
            "min": -100,
            "max": -30,
            "curve": 1
          },
          "angle": 0
        },
        "speed": {
          "rotation": 0.1
        }
      }
    },
    "ripple": {
      "impact": 0,
      "center": [
        0,
        0
      ],
      "scale": 5,
      "phase": 0,
      "speed": {
        "phase": 1
      }
    },
    "glass": {
      "refraction": 0,
      "color": {
        "impact": 0,
        "base": [
          1,
          1,
          1
        ],
        "tint": [
          1,
          1,
          1
        ]
      },
      "center": [
        0,
        0
      ],
      "vertices": 5,
      "width": 0.5,
      "edge": {
        "width": 0.1,
        "thickness": 0.1,
        "smoothing": 0.05
      },
      "angle": 0,
      "phase": 0,
      "fade": 1,
      "perspective": false,
      "scale": 1,
      "speed": {
        "phase": 1,
        "rotation": 0.1
      }
    }
  },
  "mapping": "visualizer.draw.shape.size = controls.draw.shape.size + cos(music.beat.period(1)) * .1;\n"
},"aimi-level-4":{
  "title": "Deep",
  "description": "Deep house beats to lift you up and engage your senses. House. It’s a music genre that continues to expand the realm of possibility. These deep house beats will lift you up, engage you and connect with you on a deeper level.",
  "controls": {
    "analyser": {
      "frequency": {
        "samples": 10,
        "stereo": true,
        "smoothing": 0.8,
        "logScale": false
      },
      "waveform": {
        "samples": 11
      }
    },
    "color": {
      "gammaCorrection": 1,
      "invert": false
    },
    "feedback": {
      "fade": {
        "rate": 0.95,
        "color": [
          1,
          1,
          1
        ]
      },
      "rotation": {
        "center": [
          0,
          0
        ],
        "angle": 0
      },
      "zoom": {
        "center": [
          0,
          0
        ],
        "scale": 1,
        "frequency": {
          "impact": 0,
          "range": {
            "min": 0,
            "max": 1,
            "logScale": false
          },
          "loudness": {
            "min": -100,
            "max": -30,
            "curve": 1
          },
          "angle": 0
        },
        "waveform": {
          "impact": 0,
          "mirror": true,
          "angle": 0
        }
      },
      "shift": {
        "rate": [
          0,
          0
        ],
        "frequency": {
          "horizontal": {
            "impact": 0,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            }
          },
          "vertical": {
            "impact": 0,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            }
          }
        },
        "waveform": {
          "horizontal": {
            "impact": 0
          },
          "vertical": {
            "impact": 0
          }
        }
      },
      "noise": {
        "impact": 0,
        "scale": 1,
        "phase": 0,
        "shift": [
          0,
          0
        ],
        "speed": {
          "phase": 0.2,
          "shift": [
            0,
            0
          ]
        }
      }
    },
    "draw": {
      "noise": {
        "mix": false,
        "intensity": 0,
        "color": [
          1,
          1,
          1
        ],
        "scale": 1,
        "phase": 0,
        "shift": [
          0,
          0
        ],
        "slice": {
          "start": 0,
          "end": 0.5,
          "frequency": {
            "apply": false,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            },
            "shift": 0
          }
        },
        "edge": {
          "inner": {
            "start": 0,
            "end": 0.0001
          },
          "outer": {
            "start": 0.4999,
            "end": 0.5
          }
        },
        "spectrum": {
          "intensity": 0,
          "color": [
            1,
            1,
            1
          ]
        },
        "palette": {
          "intensity": 0,
          "a": [
            0.5,
            0.5,
            0.5
          ],
          "b": [
            0.5,
            0.5,
            0.5
          ],
          "c": [
            1,
            1,
            1
          ],
          "d": [
            0,
            0.33,
            0.67
          ]
        },
        "speed": {
          "phase": 0.2,
          "shift": [
            0,
            0
          ]
        }
      },
      "shape": {
        "mix": false,
        "intensity": 1,
        "color": [
          1,
          1,
          1
        ],
        "center": [
          0,
          0
        ],
        "vertices": 5,
        "size": 0.618033,
        "angle": 0,
        "slice": {
          "start": 0.97,
          "end": 1,
          "frequency": {
            "apply": false,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            },
            "shift": 0
          }
        },
        "edge": {
          "inner": {
            "start": 0.96,
            "end": 0.97
          },
          "outer": {
            "start": 0.99,
            "end": 1
          }
        },
        "spectrum": {
          "intensity": 0,
          "color": [
            1,
            1,
            1
          ]
        },
        "palette": {
          "intensity": 0,
          "a": [
            0.5,
            0.5,
            0.5
          ],
          "b": [
            0.5,
            0.5,
            0.5
          ],
          "c": [
            1,
            1,
            1
          ],
          "d": [
            0,
            0.33,
            0.67
          ]
        },
        "frequency": {
          "impact": 0,
          "range": {
            "min": 0,
            "max": 1,
            "logScale": false
          },
          "loudness": {
            "min": -100,
            "max": -30,
            "curve": 1
          },
          "angle": 0
        },
        "speed": {
          "rotation": 0.1
        }
      }
    },
    "ripple": {
      "impact": 0,
      "center": [
        0,
        0
      ],
      "scale": 5,
      "phase": 0,
      "speed": {
        "phase": 1
      }
    },
    "glass": {
      "refraction": 0,
      "color": {
        "impact": 0,
        "base": [
          1,
          1,
          1
        ],
        "tint": [
          1,
          1,
          1
        ]
      },
      "center": [
        0,
        0
      ],
      "vertices": 5,
      "width": 0.5,
      "edge": {
        "width": 0.1,
        "thickness": 0.1,
        "smoothing": 0.05
      },
      "angle": 0,
      "phase": 0,
      "fade": 1,
      "perspective": false,
      "scale": 1,
      "speed": {
        "phase": 1,
        "rotation": 0.1
      }
    }
  },
  "mapping": "visualizer.draw.shape.size = controls.draw.shape.size + cos(music.beat.period(1)) * .1;\n"
},"aimi-level-5":{
  "title": "Push",
  "description": "When you want to max out, these high energy beats will push you to your limits. When you need to max out, experience Push. This is the place to come to experience high-energy beats that push you to the limits with rhythms that keep you coming back for more.",
  "controls": {
    "analyser": {
      "frequency": {
        "samples": 10,
        "stereo": true,
        "smoothing": 0.8,
        "logScale": false
      },
      "waveform": {
        "samples": 11
      }
    },
    "color": {
      "gammaCorrection": 1,
      "invert": false
    },
    "feedback": {
      "fade": {
        "rate": 0.95,
        "color": [
          1,
          1,
          1
        ]
      },
      "rotation": {
        "center": [
          0,
          0
        ],
        "angle": 0
      },
      "zoom": {
        "center": [
          0,
          0
        ],
        "scale": 1,
        "frequency": {
          "impact": 0,
          "range": {
            "min": 0,
            "max": 1,
            "logScale": false
          },
          "loudness": {
            "min": -100,
            "max": -30,
            "curve": 1
          },
          "angle": 0
        },
        "waveform": {
          "impact": 0,
          "mirror": true,
          "angle": 0
        }
      },
      "shift": {
        "rate": [
          0,
          0
        ],
        "frequency": {
          "horizontal": {
            "impact": 0,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            }
          },
          "vertical": {
            "impact": 0,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            }
          }
        },
        "waveform": {
          "horizontal": {
            "impact": 0
          },
          "vertical": {
            "impact": 0
          }
        }
      },
      "noise": {
        "impact": 0,
        "scale": 1,
        "phase": 0,
        "shift": [
          0,
          0
        ],
        "speed": {
          "phase": 0.2,
          "shift": [
            0,
            0
          ]
        }
      }
    },
    "draw": {
      "noise": {
        "mix": false,
        "intensity": 0,
        "color": [
          1,
          1,
          1
        ],
        "scale": 1,
        "phase": 0,
        "shift": [
          0,
          0
        ],
        "slice": {
          "start": 0,
          "end": 0.5,
          "frequency": {
            "apply": false,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            },
            "shift": 0
          }
        },
        "edge": {
          "inner": {
            "start": 0,
            "end": 0.0001
          },
          "outer": {
            "start": 0.4999,
            "end": 0.5
          }
        },
        "spectrum": {
          "intensity": 0,
          "color": [
            1,
            1,
            1
          ]
        },
        "palette": {
          "intensity": 0,
          "a": [
            0.5,
            0.5,
            0.5
          ],
          "b": [
            0.5,
            0.5,
            0.5
          ],
          "c": [
            1,
            1,
            1
          ],
          "d": [
            0,
            0.33,
            0.67
          ]
        },
        "speed": {
          "phase": 0.2,
          "shift": [
            0,
            0
          ]
        }
      },
      "shape": {
        "mix": false,
        "intensity": 1,
        "color": [
          1,
          1,
          1
        ],
        "center": [
          0,
          0
        ],
        "vertices": 6,
        "size": 0.618033,
        "angle": 0,
        "slice": {
          "start": 0.97,
          "end": 1,
          "frequency": {
            "apply": false,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            },
            "shift": 0
          }
        },
        "edge": {
          "inner": {
            "start": 0.96,
            "end": 0.97
          },
          "outer": {
            "start": 0.99,
            "end": 1
          }
        },
        "spectrum": {
          "intensity": 0,
          "color": [
            1,
            1,
            1
          ]
        },
        "palette": {
          "intensity": 0,
          "a": [
            0.5,
            0.5,
            0.5
          ],
          "b": [
            0.5,
            0.5,
            0.5
          ],
          "c": [
            1,
            1,
            1
          ],
          "d": [
            0,
            0.33,
            0.67
          ]
        },
        "frequency": {
          "impact": 0,
          "range": {
            "min": 0,
            "max": 1,
            "logScale": false
          },
          "loudness": {
            "min": -100,
            "max": -30,
            "curve": 1
          },
          "angle": 0
        },
        "speed": {
          "rotation": 0.1
        }
      }
    },
    "ripple": {
      "impact": 0,
      "center": [
        0,
        0
      ],
      "scale": 5,
      "phase": 0,
      "speed": {
        "phase": 1
      }
    },
    "glass": {
      "refraction": 0,
      "color": {
        "impact": 0,
        "base": [
          1,
          1,
          1
        ],
        "tint": [
          1,
          1,
          1
        ]
      },
      "center": [
        0,
        0
      ],
      "vertices": 5,
      "width": 0.5,
      "edge": {
        "width": 0.1,
        "thickness": 0.1,
        "smoothing": 0.05
      },
      "angle": 0,
      "phase": 0,
      "fade": 1,
      "perspective": false,
      "scale": 1,
      "speed": {
        "phase": 1,
        "rotation": 0.1
      }
    }
  },
  "mapping": "visualizer.draw.shape.size = controls.draw.shape.size + cos(music.beat.period(1)) * .1;\n"
},"generic":{
  "title": "Candy",
  "description": "Playful colors and immersive fluid movement",
  "controls": {
    "analyser": {
      "frequency": {
        "samples": 10,
        "stereo": true,
        "smoothing": 0.8,
        "logScale": false
      },
      "waveform": {
        "samples": 11
      }
    },
    "color": {
      "gammaCorrection": 1,
      "invert": false
    },
    "feedback": {
      "fade": {
        "rate": 0.989407214460494,
        "color": [
          1,
          1,
          1
        ]
      },
      "rotation": {
        "center": [
          0,
          0
        ],
        "angle": 0
      },
      "zoom": {
        "center": [
          0,
          0
        ],
        "scale": 1.01329758211608,
        "frequency": {
          "impact": 0,
          "range": {
            "min": 0,
            "max": 1,
            "logScale": false
          },
          "loudness": {
            "min": -100,
            "max": -30,
            "curve": 1
          },
          "angle": 0
        },
        "waveform": {
          "impact": 0,
          "mirror": true,
          "angle": 0
        }
      },
      "shift": {
        "rate": [
          0,
          0
        ],
        "frequency": {
          "horizontal": {
            "impact": 0,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            }
          },
          "vertical": {
            "impact": 0,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            }
          }
        },
        "waveform": {
          "horizontal": {
            "impact": 0
          },
          "vertical": {
            "impact": 0
          }
        }
      },
      "noise": {
        "impact": 0.0345518138779428,
        "scale": 3.2810365848069,
        "phase": 0,
        "shift": [
          0,
          0
        ],
        "speed": {
          "phase": 0.2,
          "shift": [
            0,
            0
          ]
        }
      }
    },
    "draw": {
      "noise": {
        "mix": false,
        "intensity": 0.0175664199927211,
        "color": [
          0.28627450980392155,
          0.3607843137254902,
          0.5333333333333333
        ],
        "scale": 2.85165431745236,
        "phase": 0,
        "shift": [
          0,
          0
        ],
        "slice": {
          "start": 0.478079620969727,
          "end": 0.509501278576569,
          "frequency": {
            "apply": false,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            },
            "shift": 0
          }
        },
        "edge": {
          "inner": {
            "start": 0.474918617268641,
            "end": 0.504204662932617
          },
          "outer": {
            "start": 0.541481940784375,
            "end": 0.627042540387909
          }
        },
        "spectrum": {
          "intensity": 0.0135549934926209,
          "color": [
            1,
            1,
            1
          ]
        },
        "palette": {
          "intensity": 0,
          "a": [
            0.5,
            0.5,
            0.5
          ],
          "b": [
            0.5,
            0.5,
            0.5
          ],
          "c": [
            1,
            1,
            1
          ],
          "d": [
            0,
            0.33,
            0.67
          ]
        },
        "speed": {
          "phase": 0.2,
          "shift": [
            0,
            0
          ]
        }
      },
      "shape": {
        "mix": false,
        "intensity": 0,
        "color": [
          1,
          1,
          1
        ],
        "center": [
          0,
          0
        ],
        "vertices": 3,
        "size": 2.44855573470336,
        "angle": 0,
        "slice": {
          "start": 1,
          "end": 0,
          "frequency": {
            "apply": false,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            },
            "shift": 0
          }
        },
        "edge": {
          "inner": {
            "start": 0,
            "end": 0.016842934562036
          },
          "outer": {
            "start": 0.987151393229634,
            "end": 1
          }
        },
        "spectrum": {
          "intensity": 0.00961934031895071,
          "color": [
            1,
            1,
            1
          ]
        },
        "palette": {
          "intensity": 0,
          "a": [
            0.5,
            0.5,
            0.5
          ],
          "b": [
            0.5,
            0.5,
            0.5
          ],
          "c": [
            1,
            1,
            1
          ],
          "d": [
            0,
            0.33,
            0.67
          ]
        },
        "frequency": {
          "impact": 0,
          "range": {
            "min": 0,
            "max": 1,
            "logScale": false
          },
          "loudness": {
            "min": -100,
            "max": -30,
            "curve": 1
          },
          "angle": 0
        },
        "speed": {
          "rotation": 0.1
        }
      }
    },
    "ripple": {
      "impact": 0,
      "center": [
        0,
        0
      ],
      "scale": 5,
      "phase": 0,
      "speed": {
        "phase": 1
      }
    },
    "glass": {
      "refraction": 0,
      "color": {
        "impact": 0,
        "base": [
          1,
          1,
          1
        ],
        "tint": [
          1,
          1,
          1
        ]
      },
      "center": [
        0,
        0
      ],
      "vertices": 5,
      "width": 0.5,
      "edge": {
        "width": 0.1,
        "thickness": 0.1,
        "smoothing": 0.05
      },
      "angle": 0,
      "phase": 0,
      "fade": 1,
      "perspective": false,
      "scale": 1,
      "speed": {
        "phase": 1,
        "rotation": 0.1
      }
    }
  },
  "mapping": "visualizer.feedback.zoom.scale = visualizer.feedback.zoom.scale + wave(music.beat.period(4)) * .01;\nvisualizer.draw.noise.spectrum.color = multiplyVectors(spectralColor((music.beat.signal(4)) % 1), [.05, .05, .05]);\nvisualizer.feedback.rotation.angle = cos(music.beat.period(16)) * .023;\nvisualizer.draw.shape.center = [0, sin(music.beat.period(16)) * 2];\nvisualizer.feedback.noise.scale = visualizer.feedback.noise.scale + wave(music.beat.period(8)) * 1;\nvisualizer.feedback.noise.impact = visualizer.feedback.noise.impact + wave(music.beat.period(1)) * .01;\n"
},"negentropy-ripples":{
  "title": "Negentropy + ripples",
  "description": "Noise feedback + spectral colors + frequency impact + ripples",
  "controls": {
    "analyser": {
      "frequency": {
        "samples": 10,
        "stereo": true,
        "smoothing": 0.8,
        "logScale": false
      },
      "waveform": {
        "samples": 8
      }
    },
    "color": {
      "gammaCorrection": 1,
      "invert": false
    },
    "feedback": {
      "fade": {
        "rate": 0.988663665414849,
        "color": [
          1,
          1,
          1
        ]
      },
      "rotation": {
        "center": [
          0,
          0
        ],
        "angle": 0.826962268374
      },
      "zoom": {
        "center": [
          0,
          0
        ],
        "scale": 0.972109491712837,
        "frequency": {
          "impact": -0.0163631343265663,
          "range": {
            "min": 0.0134777634777635,
            "max": 0.884163556321179,
            "logScale": false
          },
          "loudness": {
            "min": -100,
            "max": -30,
            "curve": 1
          },
          "angle": 7.09230677551999
        },
        "waveform": {
          "impact": 0.150593658835252,
          "mirror": true,
          "angle": -0.141588701507664
        }
      },
      "shift": {
        "rate": [
          0,
          0
        ],
        "frequency": {
          "horizontal": {
            "impact": 0.000328016230729,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            }
          },
          "vertical": {
            "impact": 0,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            }
          }
        },
        "waveform": {
          "horizontal": {
            "impact": 0
          },
          "vertical": {
            "impact": 0
          }
        }
      },
      "noise": {
        "impact": 0.0236826805567091,
        "scale": 4.5161802590253,
        "phase": 0,
        "shift": [
          0,
          0
        ],
        "speed": {
          "phase": 1,
          "shift": [
            0,
            0
          ]
        }
      }
    },
    "draw": {
      "noise": {
        "mix": false,
        "intensity": 0,
        "color": [
          0.7176470588235294,
          0.37254901960784315,
          0.7843137254901961
        ],
        "scale": 10.3845384714919,
        "phase": 0,
        "shift": [
          0,
          0
        ],
        "slice": {
          "start": 0,
          "end": 0.55,
          "frequency": {
            "apply": false,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            },
            "shift": 0
          }
        },
        "edge": {
          "inner": {
            "start": 0.7,
            "end": 0.8
          },
          "outer": {
            "start": 0.9,
            "end": 1
          }
        },
        "spectrum": {
          "intensity": 0,
          "color": [
            1,
            1,
            1
          ]
        },
        "palette": {
          "intensity": 0,
          "a": [
            0.5,
            0.5,
            0.5
          ],
          "b": [
            0.5,
            0.5,
            0.5
          ],
          "c": [
            1,
            1,
            1
          ],
          "d": [
            0,
            0.33,
            0.67
          ]
        },
        "speed": {
          "phase": 2.85879991288621,
          "shift": [
            0,
            0
          ]
        }
      },
      "shape": {
        "mix": false,
        "intensity": 0,
        "color": [
          1,
          1,
          1
        ],
        "center": [
          0,
          0
        ],
        "size": 0.887807610179578,
        "angle": 0,
        "slice": {
          "start": 1,
          "end": 0.496590292361783,
          "frequency": {
            "apply": false,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            },
            "shift": 0
          }
        },
        "edge": {
          "inner": {
            "start": 0,
            "end": 0.0786520877599255
          },
          "outer": {
            "start": 0.994683335129504,
            "end": 1
          }
        },
        "spectrum": {
          "intensity": 0.138687897780897,
          "color": [
            0.8901960784313725,
            0.5019607843137255,
            1
          ]
        },
        "palette": {
          "intensity": 0,
          "a": [
            0.5,
            0.5,
            0.5
          ],
          "b": [
            0.5,
            0.5,
            0.5
          ],
          "c": [
            1,
            1,
            1
          ],
          "d": [
            0,
            0.33,
            0.67
          ]
        },
        "frequency": {
          "impact": 0,
          "range": {
            "min": 0,
            "max": 1,
            "logScale": false
          },
          "loudness": {
            "min": -100,
            "max": -30,
            "curve": 1
          },
          "angle": 0
        },
        "speed": {
          "rotation": 0.1
        }
      }
    },
    "ripple": {
      "impact": 0.11318071680497,
      "center": [
        0,
        0
      ],
      "scale": 5.15326934334377,
      "phase": 0,
      "speed": {
        "phase": 0.095564489553812,
        "movement": 40
      }
    },
    "glass": {
      "refraction": 0,
      "color": {
        "impact": 0,
        "base": [
          1,
          1,
          1
        ],
        "tint": [
          1,
          1,
          1
        ]
      },
      "center": [
        0,
        0
      ],
      "vertices": 5,
      "width": 0.5,
      "edge": {
        "width": 0.1,
        "thickness": 0.1,
        "smoothing": 0.05
      },
      "angle": 0,
      "phase": 0,
      "fade": 1,
      "perspective": false,
      "scale": 1,
      "speed": {
        "phase": 1,
        "rotation": 0.1
      }
    }
  },
  "mapping": "visualizer.feedback.rotation.angle = sin(music.beat.period(4)) * .04;\nvisualizer.ripple.scale = controls.ripple.scale + sin(music.beat.period(8)) * 1;\n"
},"candy":{
  "title": "Candy",
  "description": "Playful colors and immersive fluid movement",
  "controls": {
    "analyser": {
      "frequency": {
        "samples": 10,
        "stereo": true,
        "smoothing": 0.8,
        "logScale": false
      },
      "waveform": {
        "samples": 11
      }
    },
    "color": {
      "gammaCorrection": 1,
      "invert": false
    },
    "feedback": {
      "fade": {
        "rate": 0.989407214460494,
        "color": [
          1,
          1,
          1
        ]
      },
      "rotation": {
        "center": [
          0,
          0
        ],
        "angle": 0
      },
      "zoom": {
        "center": [
          0,
          0
        ],
        "scale": 1.01329758211608,
        "frequency": {
          "impact": 0,
          "range": {
            "min": 0,
            "max": 1,
            "logScale": false
          },
          "loudness": {
            "min": -100,
            "max": -30,
            "curve": 1
          },
          "angle": 0
        },
        "waveform": {
          "impact": 0,
          "mirror": true,
          "angle": 0
        }
      },
      "shift": {
        "rate": [
          0,
          0
        ],
        "frequency": {
          "horizontal": {
            "impact": 0,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            }
          },
          "vertical": {
            "impact": 0,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            }
          }
        },
        "waveform": {
          "horizontal": {
            "impact": 0
          },
          "vertical": {
            "impact": 0
          }
        }
      },
      "noise": {
        "impact": 0.0345518138779428,
        "scale": 3.2810365848069,
        "phase": 0,
        "shift": [
          0,
          0
        ],
        "speed": {
          "phase": 0.2,
          "shift": [
            0,
            0
          ]
        }
      }
    },
    "draw": {
      "noise": {
        "mix": false,
        "intensity": 0.0175664199927211,
        "color": [
          0.28627450980392155,
          0.3607843137254902,
          0.5333333333333333
        ],
        "scale": 2.85165431745236,
        "phase": 0,
        "shift": [
          0,
          0
        ],
        "slice": {
          "start": 0.478079620969727,
          "end": 0.509501278576569,
          "frequency": {
            "apply": false,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            },
            "shift": 0
          }
        },
        "edge": {
          "inner": {
            "start": 0.474918617268641,
            "end": 0.504204662932617
          },
          "outer": {
            "start": 0.541481940784375,
            "end": 0.627042540387909
          }
        },
        "spectrum": {
          "intensity": 0.0135549934926209,
          "color": [
            1,
            1,
            1
          ]
        },
        "palette": {
          "intensity": 0,
          "a": [
            0.5,
            0.5,
            0.5
          ],
          "b": [
            0.5,
            0.5,
            0.5
          ],
          "c": [
            1,
            1,
            1
          ],
          "d": [
            0,
            0.33,
            0.67
          ]
        },
        "speed": {
          "phase": 0.2,
          "shift": [
            0,
            0
          ]
        }
      },
      "shape": {
        "mix": false,
        "intensity": 0,
        "color": [
          1,
          1,
          1
        ],
        "center": [
          0,
          0
        ],
        "vertices": 3,
        "size": 2.44855573470336,
        "angle": 0,
        "slice": {
          "start": 1,
          "end": 0,
          "frequency": {
            "apply": false,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            },
            "shift": 0
          }
        },
        "edge": {
          "inner": {
            "start": 0,
            "end": 0.016842934562036
          },
          "outer": {
            "start": 0.987151393229634,
            "end": 1
          }
        },
        "spectrum": {
          "intensity": 0.00961934031895071,
          "color": [
            1,
            1,
            1
          ]
        },
        "palette": {
          "intensity": 0,
          "a": [
            0.5,
            0.5,
            0.5
          ],
          "b": [
            0.5,
            0.5,
            0.5
          ],
          "c": [
            1,
            1,
            1
          ],
          "d": [
            0,
            0.33,
            0.67
          ]
        },
        "frequency": {
          "impact": 0,
          "range": {
            "min": 0,
            "max": 1,
            "logScale": false
          },
          "loudness": {
            "min": -100,
            "max": -30,
            "curve": 1
          },
          "angle": 0
        },
        "speed": {
          "rotation": 0.1
        }
      }
    },
    "ripple": {
      "impact": 0,
      "center": [
        0,
        0
      ],
      "scale": 5,
      "phase": 0,
      "speed": {
        "phase": 1
      }
    },
    "glass": {
      "refraction": 0,
      "color": {
        "impact": 0,
        "base": [
          1,
          1,
          1
        ],
        "tint": [
          1,
          1,
          1
        ]
      },
      "center": [
        0,
        0
      ],
      "vertices": 5,
      "width": 0.5,
      "edge": {
        "width": 0.1,
        "thickness": 0.1,
        "smoothing": 0.05
      },
      "angle": 0,
      "phase": 0,
      "fade": 1,
      "perspective": false,
      "scale": 1,
      "speed": {
        "phase": 1,
        "rotation": 0.1
      }
    }
  },
  "mapping": "visualizer.feedback.zoom.scale = visualizer.feedback.zoom.scale + wave(music.beat.period(4)) * .01;\nvisualizer.draw.noise.spectrum.color = multiplyVectors(spectralColor((music.beat.signal(4)) % 1), [.05, .05, .05]);\nvisualizer.feedback.rotation.angle = cos(music.beat.period(16)) * .023;\nvisualizer.draw.shape.center = [0, sin(music.beat.period(16)) * 2];\nvisualizer.feedback.noise.scale = visualizer.feedback.noise.scale + wave(music.beat.period(8)) * 1;\nvisualizer.feedback.noise.impact = visualizer.feedback.noise.impact + wave(music.beat.period(1)) * .01;\n"
},"shumi-ocean-dance":{
  "title": "Ocean Dance",
  "description": "A default experience derived from the default values, good starting point for customization (including this description)",
  "controls": {
    "analyser": {
      "frequency": {
        "samples": 6,
        "stereo": false,
        "smoothing": 0.840169992609017,
        "logScale": false
      },
      "waveform": {
        "samples": 11
      }
    },
    "color": {
      "gammaCorrection": 4.48237481347391,
      "invert": true
    },
    "feedback": {
      "fade": {
        "rate": 0.820198165774126,
        "color": [
          1,
          0.8549019607843137,
          0.8470588235294118
        ]
      },
      "rotation": {
        "center": [
          0.0825749263108068,
          0.148669291507993
        ],
        "angle": -211.849174692025
      },
      "zoom": {
        "center": [
          0,
          0
        ],
        "scale": 0.894180243167777,
        "frequency": {
          "impact": 0.168109028960818,
          "range": {
            "min": 0.0784203798802503,
            "max": 1,
            "logScale": false
          },
          "loudness": {
            "min": -100,
            "max": -30,
            "curve": 2.40403301401495
          },
          "angle": 48.5892544548678
        },
        "waveform": {
          "impact": 0.68,
          "mirror": true,
          "angle": -173.754656851744
        }
      },
      "shift": {
        "rate": [
          0.0770885776372126,
          0.167968329783343
        ],
        "frequency": {
          "horizontal": {
            "impact": -0.31870573531454,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            }
          },
          "vertical": {
            "impact": 0,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            }
          }
        },
        "waveform": {
          "horizontal": {
            "impact": 0
          },
          "vertical": {
            "impact": 0
          }
        }
      },
      "noise": {
        "impact": 0.202033716885202,
        "scale": 2.02438273640701,
        "shift": [
          -2.15150928376e-7,
          0.000027324167903784
        ],
        "speed": {
          "movement": -2.00802787390823,
          "shift": [
            -0.000039421813403416,
            -0.000039421813403416
          ]
        }
      }
    },
    "draw": {
      "noise": {
        "mix": false,
        "intensity": 0.172631959508315,
        "color": [
          0.9019607843137255,
          0.23137254901960785,
          0.47843137254901963
        ],
        "scale": 1,
        "shift": [
          0,
          0
        ],
        "slice": {
          "start": 0,
          "end": 0.55
        },
        "edge": {
          "inner": {
            "start": 0.448830640605581,
            "end": 0.484770147240643
          },
          "outer": {
            "start": 0.130674500056491,
            "end": 0.801281330785658
          }
        },
        "spectrum": {
          "intensity": 0.825954831134747,
          "color": [
            1,
            1,
            1
          ]
        },
        "speed": {
          "movement": 0.884831791322362,
          "shift": [
            0.863337713534823,
            0
          ]
        }
      },
      "shape": {
        "mix": false,
        "intensity": 1,
        "color": [
          1,
          1,
          1
        ],
        "center": [
          0,
          0
        ],
        "size": 0.618033,
        "angle": 0,
        "slice": {
          "start": 0.97,
          "end": 1
        },
        "edge": {
          "inner": {
            "start": 0.96,
            "end": 0.97
          },
          "outer": {
            "start": 0.99,
            "end": 1
          }
        },
        "spectrum": {
          "intensity": 0,
          "color": [
            1,
            1,
            1
          ]
        },
        "speed": {
          "rotation": 0.1
        }
}
    },
    "ripple": {
      "center": [
        0,
        0
      ],
      "impact": 0,
      "scale": 10,
      "speed": {
        "phase": 1
      }
    },
    "glass": {
      "refraction": 0,
      "color": {
        "impact": 0,
        "base": [
          1,
          1,
          1
        ],
        "tint": [
          1,
          1,
          1
        ]
      },
      "center": [
        0,
        0
      ],
      "vertices": 5,
      "width": 0.5,
      "edge": {
        "width": 0.1,
        "thickness": 0.1,
        "smoothing": 0.05
      },
      "angle": 0,
      "phase": 0,
      "fade": 1,
      "perspective": false,
      "scale": 1,
      "speed": {
        "phase": 1,
        "rotation": 0.1
      }
    }
  },
  "mapping": "visualizer.draw.shape.size + sin(seconds) * .1\n"
}
,


"hammer": {
  "title": "Candy",
  "description": "Playful colors and immersive fluid movement",
  "controls": {
    "analyser": {
      "frequency": {
        "samples": 10,
        "stereo": true,
        "smoothing": 0.8,
        "logScale": false
      },
      "waveform": {
        "samples": 11
      }
    },
    "color": {
      "gammaCorrection": 1,
      "invert": false
    },
    "feedback": {
      "fade": {
        "rate": 0.989407214460494,
        "color": [
          1,
          1,
          1
        ]
      },
      "rotation": {
        "center": [
          0,
          0
        ],
        "angle": 0
      },
      "zoom": {
        "center": [
          0,
          0
        ],
        "scale": 1.01329758211608,
        "frequency": {
          "impact": -0.440067098011023,
          "range": {
            "min": 0.130940259986267,
            "max": 0.454105127532152,
            "logScale": true
          },
          "loudness": {
            "min": -92.8160443255274,
            "max": -30,
            "curve": 1.36940822953521
          },
          "angle": 0
        },
        "waveform": {
          "impact": 0,
          "mirror": true,
          "angle": 0
        }
      },
      "shift": {
        "rate": [
          0,
          0
        ],
        "frequency": {
          "horizontal": {
            "impact": 0,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            }
          },
          "vertical": {
            "impact": 0,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            }
          }
        },
        "waveform": {
          "horizontal": {
            "impact": 0
          },
          "vertical": {
            "impact": 0
          }
        }
      },
      "noise": {
        "impact": 0.0345518138779428,
        "scale": 3.2810365848069,
        "phase": 0,
        "shift": [
          0,
          0
        ],
        "speed": {
          "phase": 0.2,
          "shift": [
            0,
            0
          ]
        }
      }
    },
    "draw": {
      "noise": {
        "mix": false,
        "mixFactor": 1,
        "intensity": 0.0175664199927211,
        "color": [
          0.28627450980392155,
          0.3607843137254902,
          0.5333333333333333
        ],
        "scale": 2.85165431745236,
        "phase": 0,
        "shift": [
          0,
          0
        ],
        "slice": {
          "start": 0.478079620969727,
          "end": 0.509501278576569,
          "frequency": {
            "apply": false,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            },
            "shift": 0
          }
        },
        "edge": {
          "inner": {
            "start": 0.474918617268641,
            "end": 0.504204662932617
          },
          "outer": {
            "start": 0.541481940784375,
            "end": 0.627042540387909
          }
        },
        "spectrum": {
          "intensity": 0.0135549934926209,
          "color": [
            1,
            1,
            1
          ]
        },
        "palette": {
          "intensity": 0,
          "a": [
            0.5,
            0.5,
            0.5
          ],
          "b": [
            0.5,
            0.5,
            0.5
          ],
          "c": [
            1,
            1,
            1
          ],
          "d": [
            0,
            0.33,
            0.67
          ]
        },
        "speed": {
          "phase": 0.2,
          "shift": [
            0,
            0
          ]
        }
      },
      "shape": {
        "mix": false,
        "mixFactor": 1,
        "intensity": 0,
        "color": [
          1,
          1,
          1
        ],
        "center": [
          0,
          0
        ],
        "vertices": 3,
        "size": 2.44855573470336,
        "angle": 0,
        "slice": {
          "start": 1,
          "end": 0,
          "frequency": {
            "apply": false,
            "range": {
              "min": 0,
              "max": 1,
              "logScale": false
            },
            "loudness": {
              "min": -100,
              "max": -30,
              "curve": 1
            },
            "shift": 0
          }
        },
        "edge": {
          "inner": {
            "start": 0,
            "end": 0.016842934562036
          },
          "outer": {
            "start": 0.987151393229634,
            "end": 1
          }
        },
        "spectrum": {
          "intensity": 0.00961934031895071,
          "color": [
            1,
            1,
            1
          ]
        },
        "palette": {
          "intensity": 0,
          "a": [
            0.5,
            0.5,
            0.5
          ],
          "b": [
            0.5,
            0.5,
            0.5
          ],
          "c": [
            1,
            1,
            1
          ],
          "d": [
            0,
            0.33,
            0.67
          ]
        },
        "frequency": {
          "impact": 0,
          "range": {
            "min": 0,
            "max": 1,
            "logScale": false
          },
          "loudness": {
            "min": -100,
            "max": -30,
            "curve": 1
          },
          "angle": 0
        },
        "speed": {
          "rotation": 0.1
        }
      }
    },
    "ripple": {
      "impact": 0.220799671367931,
      "center": [
        0,
        0
      ],
      "scale": 2.60516091360298,
      "phase": 0,
      "speed": {
        "phase": 1
      }
    },
    "glass": {
      "refraction": 0.428689355881035,
      "color": {
        "impact": 0.535442090989854,
        "base": [
          0.5803921568627451,
          0.1411764705882353,
          0.1411764705882353
        ],
        "tint": [
          1,
          1,
          1
        ]
      },
      "center": [
        0,
        0
      ],
      "vertices": 3,
      "width": 0.5,
      "edge": {
        "width": 0.1,
        "thickness": 0.1,
        "smoothing": 0.05
      },
      "angle": 0,
      "phase": 0,
      "fade": 1,
      "perspective": false,
      "scale": 1,
      "speed": {
        "phase": 1,
        "rotation": 0.1
      }
    }
  },
  "mapping": "visualizer.feedback.zoom.scale = visualizer.feedback.zoom.scale + wave(music.beat.period(4)) * .01;\nvisualizer.draw.noise.spectrum.color = multiplyVectors(spectralColor((music.beat.signal(4)) % 1), [.05, .05, .05]);\nvisualizer.feedback.rotation.angle = cos(music.beat.period(16)) * .023;\nvisualizer.draw.shape.center = [0, sin(music.beat.period(16)) * 2];\nvisualizer.feedback.noise.scale = visualizer.feedback.noise.scale + wave(music.beat.period(8)) * 1;\nvisualizer.feedback.noise.impact = visualizer.feedback.noise.impact + wave(music.beat.period(1)) * .01;\n"
}

,




      }

    })();
  </script>
</head>
<body class="preview-iphone">
<section id="controls">
  <h1> <input id="audio-file" name="audio-file" type="file" accept="audio/*" /></h1>
  <audio id="audio-track" controls loop></audio>
  <div id="mode-selectors">
    <select id="select-experience"></select>
    experience on
    <select id="select-preview">
      <option value="iphone">iPhone &#9647;</option>
      <option value="ipad">iPad &#9647;</option>
      <option value="iphone-landscape">iPhone &#9645;</option>
      <option value="ipad-landscape">iPad &#9645;</option>
      <option value="square">square</option>
      <option value="4x5">4x5</option>
      <option value="fullscreen">Fullscreen</option>
    </select>
  </div>
  <div id="experience-data">
    <textarea id="experience-title" rows="1"></textarea>
    <textarea id="experience-description"></textarea>
    <button id="action-copy-state" class="visualizer-action-button">Copy experience to clipboard</button>
  </div>
  <div id="music">
  </div>
  <div id="controls-tree">
  </div>
  <div>
    <h2>Mapping editor</h2>
    <textarea id="mapping-editor" spellcheck="false">
    </textarea>
    <div class="actions">
      <button id="action-apply-mapping">Apply</button>
    </div>
    <div id="mapping-errors">
    </div>
  </div>
  <div>
    <h2>Default mapping (for reference)</h2>
    <div id="default-mapping-reference">
    </div>
  </div>
</section>
<canvas id="preview"></canvas>
</body>
</html>
